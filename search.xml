<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL：索引常见问题</title>
      <link href="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL：索引常见问题"><a href="#MySQL：索引常见问题" class="headerlink" title="MySQL：索引常见问题"></a>MySQL：索引常见问题</h1><h1 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1. 什么是索引"></a>1. 什么是索引</h1><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p><h1 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2. 索引分类"></a>2. 索引分类</h1><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><h2 id="2-1-按数据结构分类"><a href="#2-1-按数据结构分类" class="headerlink" title="2.1 按数据结构分类"></a>2.1 按数据结构分类</h2><p><img src="C:\Users\WYC\AppData\Local\Temp\Rar$DIa23988.13472\image\image_DHUHByfKRL.png"></p><h3 id="2-1-1-索引的选择"><a href="#2-1-1-索引的选择" class="headerlink" title="2.1.1 索引的选择"></a>2.1.1 索引的选择</h3><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。</p><p><strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><h3 id="2-1-2-B-Tree索引结构特点"><a href="#2-1-2-B-Tree索引结构特点" class="headerlink" title="2.1.2 B+ Tree索引结构特点"></a>2.1.2 B+ Tree索引结构特点</h3><p>B+Tree的结构特点如下：</p><ul><li>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引。</li><li>每个节点里的数据是<strong>按主键顺序存放</strong>的。</li><li>每一层父节点的索引值都会出现在下层子节点的索引值中。</li><li>每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</li></ul><h3 id="2-1-3-聚簇索引和非聚簇索引区别"><a href="#2-1-3-聚簇索引和非聚簇索引区别" class="headerlink" title="2.1.3 聚簇索引和非聚簇索引区别"></a>2.1.3 聚簇索引和非聚簇索引区别</h3><p>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li><strong>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</strong></li></ul><h3 id="2-1-4-B-Tree优点"><a href="#2-1-4-B-Tree优点" class="headerlink" title="2.1.4 B+ Tree优点"></a>2.1.4 B+ Tree优点</h3><ol><li>B+Tree vs B Tree<ol><li>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更大，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</li><li>B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找。</li></ol></li><li>B+ Tree vs 二叉树<ol><li>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为d 个。在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右。</li><li>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为<code>O(logN)</code>。</li></ol></li><li>B+ Tree vs hash<ol><li>Hash 表不适合做范围查询，它更适合做等值的查询。</li></ol></li></ol><h3 id="2-1-5-举例说明"><a href="#2-1-5-举例说明" class="headerlink" title="2.1.5 举例说明"></a>2.1.5 举例说明</h3><p>例如：</p><p>我新建一个表，如下图所示：</p><p><img src="C:\Users\WYC\AppData\Local\Temp\Rar$DIa23988.13472\image\image_TZpCJOUNTb.png"></p><p>表中添加了这些数据：</p><p><img src="C:\Users\WYC\AppData\Local\Temp\Rar$DIa23988.13472\image\image_bZYjjQireQ.png"></p><p>那么其聚簇索引的B+ Tree应该向下面一样（这里应该是双向链表，图中是单向链表）：</p><p><img src="C:\Users\WYC\AppData\Local\Temp\Rar$DIa23988.13472\image\image_Ii74Oocrq1.png"></p><p>其二级索引的B+Tree应该向下面一样：</p><p><img src="C:\Users\WYC\AppData\Local\Temp\Rar$DIa23988.13472\image\image_qMCVQd-UXS.png"></p><p>如果我用 product_no 二级索引查询商品，如下查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure><p>会先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。<strong>这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据</strong>。</p><h2 id="2-2-按物理存储分类"><a href="#2-2-按物理存储分类" class="headerlink" title="2.2 按物理存储分类"></a>2.2 按物理存储分类</h2><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p><p>这两个区别在前面也提到了：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li><strong>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</strong></li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p><h2 id="2-3-按字段特性分类"><a href="#2-3-按字段特性分类" class="headerlink" title="2.3 按字段特性分类"></a>2.3 按字段特性分类</h2><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><h3 id="2-3-1-主键索引"><a href="#2-3-1-主键索引" class="headerlink" title="2.3.1 主键索引"></a>2.3.1 主键索引</h3><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><p>在创建表时，创建主键索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="2-3-2-唯一索引"><a href="#2-3-2-唯一索引" class="headerlink" title="2.3.2 唯一索引"></a>2.3.2 唯一索引</h3><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p>在创建表时，创建唯一索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-3-普通索引"><a href="#2-3-3-普通索引" class="headerlink" title="2.3.3 普通索引"></a>2.3.3 普通索引</h3><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><p>在创建表时，创建普通索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  INDEX(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-4-前缀索引"><a href="#2-3-4-前缀索引" class="headerlink" title="2.3.4 前缀索引"></a>2.3.4 前缀索引</h3><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><p>在创建表时，创建前缀索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    column_list,</span><br><span class="line">    INDEX(column_name(length))</span><br><span class="line">); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-4-按字段个数分类"><a href="#2-4-按字段个数分类" class="headerlink" title="2.4 按字段个数分类"></a>2.4 按字段个数分类</h2><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引；</li><li>建立在多列上的索引称为联合索引；</li></ul><h3 id="2-4-1-联合索引"><a href="#2-4-1-联合索引" class="headerlink" title="2.4.1 联合索引"></a>2.4.1 联合索引</h3><p>通过将多个字段组合成一个索引，该索引就被称为联合索引。比如，将商品表中的 product_no 和 name 字段组合成联合索引<code>(product_no, name)</code>，创建联合索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure><p>联合索引<code>(product_no, name)</code> 的 B+Tree 示意图如下（叶子节点之间应该是双向链表）：</p><p><img src="C:\Users\WYC\AppData\Local\Temp\Rar$DIa23988.13472\image\image_qgiyVIF86L.png"></p><p>最左匹配原则：联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</p><h3 id="2-4-2-举例"><a href="#2-4-2-举例" class="headerlink" title="2.4.2 举例"></a>2.4.2 举例</h3><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong></p><h3 id="2-4-3-联合索引的范围查询"><a href="#2-4-3-联合索引的范围查询" class="headerlink" title="2.4.3 联合索引的范围查询"></a>2.4.3 联合索引的范围查询</h3><p>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p><p>例如，select * from t_table where a &gt; 1 and b &#x3D; 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p><p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a &gt; 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a &gt; 1 条件的第一条记录，但是a&gt;1时的b字段是无序的，所以<strong>这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</p><p>但是注意，并不是所有的范围查询都会有部分字段无法使用联合索引。</p><p>例如，<code>select * from t_table where a &gt;= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p><p>虽然在符合 a&gt;&#x3D; 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，<strong>但是对于符合 a &#x3D; 1 的二级索引记录的范围里，b 字段的值是「有序」的。</strong> 于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b &#x3D; 2 条件减少需要扫描的二级索引记录范围。所以，<strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><h3 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4 总结"></a>2.4.4 总结</h3><p>**联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。** 注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。</p><h3 id="2-4-5-索引下推优化"><a href="#2-4-5-索引下推优化" class="headerlink" title="2.4.5 索引下推优化"></a>2.4.5 索引下推优化</h3><p>现在我们知道，对于联合索引（a, b），在执行<code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><p>MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p><h3 id="2-4-6-索引区分度"><a href="#2-4-6-索引区分度" class="headerlink" title="2.4.6 索引区分度"></a>2.4.6 索引区分度</h3><p>实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><p>区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：</p><p>$$<br>区分度 &#x3D;\frac{\operatorname{distinct}(\operatorname{column})}{\operatorname{count}(*)}<br>$$</p><p>比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p><p>注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</p><h1 id="3-什么时候需要-不需要索引"><a href="#3-什么时候需要-不需要索引" class="headerlink" title="3. 什么时候需要&#x2F;不需要索引"></a>3. 什么时候需要&#x2F;不需要索引</h1><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><h2 id="3-1-什么时候适用索引"><a href="#3-1-什么时候适用索引" class="headerlink" title="3.1 什么时候适用索引"></a>3.1 什么时候适用索引</h2><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><h2 id="3-2-什么时候不需要创建索引"><a href="#3-2-什么时候不需要创建索引" class="headerlink" title="3.2 什么时候不需要创建索引"></a>3.2 什么时候不需要创建索引</h2><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女。</li><li>表数据太少的时候，不需要创建索引</li><li>经常更新的字段不用创建索引</li></ul><h2 id="3-3-优化索引的方法"><a href="#3-3-优化索引的方法" class="headerlink" title="3.3 优化索引的方法"></a>3.3 优化索引的方法</h2><h3 id="3-3-1-前缀索引优化"><a href="#3-3-1-前缀索引优化" class="headerlink" title="3.3.1 前缀索引优化"></a>3.3.1 前缀索引优化</h3><p>使用某个字段中字符串的前几个字符建立索引，使用前缀索引是为了减小索引字段大小。</p><h3 id="3-3-2-覆盖索引优化"><a href="#3-3-2-覆盖索引优化" class="headerlink" title="3.3.2 覆盖索引优化"></a>3.3.2 覆盖索引优化</h3><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。</p><h3 id="3-3-3-主键索引自增"><a href="#3-3-3-主键索引自增" class="headerlink" title="3.3.3 主键索引自增"></a>3.3.3 主键索引自增</h3><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。</p><h3 id="3-3-4-索引最好设置为NOT-NULL"><a href="#3-3-4-索引最好设置为NOT-NULL" class="headerlink" title="3.3.4 索引最好设置为NOT NULL"></a>3.3.4 索引最好设置为NOT NULL</h3><p>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</p><p>NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>，如下图的紫色部分：</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_VRRKABLu2w.png"></p><h3 id="3-3-5-防止索引失效"><a href="#3-3-5-防止索引失效" class="headerlink" title="3.3.5 防止索引失效"></a>3.3.5 防止索引失效</h3><p>之后会说</p><h1 id="4-本章总结"><a href="#4-本章总结" class="headerlink" title="4. 本章总结"></a>4. 本章总结</h1><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_ZWd3UCKZzs.png"></p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_xPU7RKZ4bp.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年12月7日</title>
      <link href="/2024/12/07/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024%E5%B9%B412%E6%9C%887%E6%97%A5/"/>
      <url>/2024/12/07/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024%E5%B9%B412%E6%9C%887%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b9c733d36aacfa30df40d063d0713a557c171bf68756786dcaa1caafabd73e7">e7fd074ae8bba43b23a7da116a4a69c676530e99fe5e6995f7e4543f56bda66d5db46ece69d2796be3598d7eb70f7836f8d5ea82220955a4632e2fa0017c438e8292704cad1205ace0ffaa328e18808fc444b620242c8d76f8db5ea870d32c6d8b0631f36ef5710876c66c11b5029580186c8ac7b0ff74e43702b8b1edb2a02d4eb25e2801da2b06b842419a0967c566d4d3d3b952d46232c7dac3caaba5c7f495cb754ec053b5fc47ec40cdde4642e664658e7004f6332b4e179d2ec866365226f4749eea809d37593e4e05d2a6ffededc483d1c4af691a23e5a2863b3e1b5c1562bed735846aa80e389eca3d6fae95704f1ec662eabd49d55f651d19ca645ee26f1b66f7c6adfc91e0bfc8b61692a768bd13cc0aee160761fda05d8ac5d320f8880c9446775915baeb39cd5f7f175d06961b15f725388ead04fc54fbbbaf7030ce8d79eee88e0348a6faeb8a422c4291185c7ffda060da4dc803d54f38773ff66252b803e31f1a1cc3521d182eb8241bc10e947f1f494333dde0c38a478309ad1af90c561b06560adae74b195f13cf88cf2fe8e1ec5a4b621141f43fcdd6eea0d833368751bbe7f8e80e13d2b4c06f47384f6570bf20e3b0f3c2bba0046f4a198e91b55373defd028a074e40bc9d082db7867e27ee155f8d093b7943250142d80a71c2867362df7f2b58b8581cdfcfa714262792978e5e68f1406fd6f1a33079e333d95548f492cbe56b8d703ff9ff65b0994bed32737bdbd6c1b2c5996a6124eee1ae9f5cc2287204eda743ddaa5d46d8aa958f222b12f38e1de101b4f93e604c2bf7f3003ccfc7162627ff2a94016d25c0b461217c5ca89b35bd5ff72e80b42f73663160b5f09474865877fb3a92f95a4e6c0a50d0ad515681f419c9496ef6d29780481842afbb2eb25bd91aa198985e7561db36504d13cbe5986ed9f17dda9e32bc147680d9ab348a130efc17fa7e722c6ab070e4399be07005378ec537445db9b636e330a6e792f5c523b2600e7875c7ebbe3592c447964c3d7975c963b571681bd2555b66306889257a37cd0fa2d6149baedba86f9c408a4cf7c1f30bf07dcff9800aa86038aede99120838c47d8c58f9c0b35c96aa630f469cbddf1a6affa3c84a1e6a4a1d1cab1b1e1b4067939282b24ddb461521e29d2295af3d496d42c22b468c4fd925d1a133c32e8aec51ada07f824b3f1e6442a102baed990fea3792d7178b7934ed3a10b0119acec5ef32ae64a8716fd1b780b1383718a0d026ba6b642dfe6a3d36dd91652183d3f13478fa06af1e63dfcda15c788011ce92a48c26988e96879f2b33a22dd7536f51d8ef97a32d4e52834994e5227eb79573095f26ab150684f23ce4764f1dcc5adf9b9a72b4f905ca1c8cae466c5c89cb5b937eb05e322ff88e7e0e7fea02f4b42819820385f6d15efd2d88567f3b4a4e3b6cc74cb21cb401e44f4dd95f6315cfea14ad851055060656fb47983530f773fd9a0b0b0e13a5b2e2a00681ebd5320abe63ad261374c1146bc8353c77bb52f58bdcbde650f71dc6ec5a69710e68d2e9e8ad8bfca6aac9da5aebc12e75a31cd493a306e5e9081b697c82d5a7bddfc66a737e26a57324c3f43a369eb57b59b623171002061afc5ab260f0d9b5416aac7c3471ed2cf2307e9b0d7bd76fa8eb9e35a87a78e7853db3f3f8aa1d8d6cc40965eeb9d3d91aea73b12275008dfbeed14f644afcdf8b420758e3f0cb6fae6e2575ce39a824eb64bb4a97f3752e84eb2887607561e7129dc13b7b0b2215492441b42020ee35dff6d5ac1ff25f928333de6993d34442012527e53b17f44fcb4d0057791ea4a04cc6ebcfdbd8acce96c45b5df0549845263daff09b548215c633492339b5080c429c979bf0cae5f42f92f2ccedb53abe77500a6aa14c7f3e83199bf2412b3f1f2794aab99206d4e8496e91b061bd229fe61075e3d51340473a69741fa9764054073367cbe27788710e7fd025e3d39948b40a8d3a141d1322f88a81c063ba996bdf5e060272b475277ef89160766aa5d75d0b9379bc4fab2529c6482b8753514c758fb7d1ad5ba0e8bd84b00382026a69a0a39d82016fe6465ddf1436bd59f9fbb56783ac38ac770a47a6858e1ed8b96dcbc9f4b8d013478666ee6c9948ae249e2cfea630cfb46b249bc37676068c91581143fdec0a67d54c83d9f4fe96e0793fcea3af7372ce94b625c24e1c5c07984ec4e120871ec287d5a9af09227a7abfe815d501c6812460f3decf587dd0cf9304a70a9d4aa17df0186d34320ced6d7da76b8a1b57b3d7118fbe09f1e0f7a9d4024ec017bbbfebd2e57ed11ee4a31f73fe9cae69a31c4de8fdcd637f5bcc459834736b39abffa2c28e388bf3f79d2fa8c3d3b85ac0eb789499f9daa9847e60161373aa1a7ed59caf02b3ee004d8200d4739c4b0f91141b486dba42e4296497bc9aa687b61d542c141b4b4c857064bf4e5ad1ea640e4c33e46e92e0c46d05a2b8ceda5939e45a135673386a347ff996d5f6204d83c7bae0f77c134fdfd5c1d863d6ca11404ede61fd217cd9cec53c0ee7743e87c8e0250c2a61430a0788f74e054a442649a2e8e747d4391ab5447707f81a50fa54e64a0948afa96bf4673eaf3be3390524399d1b507226b980dc14e7c2eb7bd12d71508d9045777634635e73f18dd855db3346e3e7493ffc60aa4c8ea439ca7cbf01584b192167e24d30e090bd169793eb42e42fc93573b7c624cd43ab4c6c8b30a1700aac7743f7036f2f0bdeb168f2cc1052adcdc9e24049883a387e37b39198060e2f67c0e2b1ea7be4b5b531c8ead40ff56da80c593e913d545206d6d73e2d7086e16af568be46724303cf586f4893093ced1a1133a0084744dda6a62f93f6ce5b80176cbf854ce407532bf22403758a3791bc367c87d0d6e1d250facf7576c65560ca5ff949eb0c462537ce2fe50bb5b21976aa093f758baa2e4e3355ea7d47e3591b028af1a908dc50fa91dba67d45baeabe14c2a583f6c0933626ce0ca51728b63a5fd28987f0fa1dc8624966f186e84e14847aa56490ec0ffaa3befdfefc45fe856250075e5581ab268281ebd264ad0518b465da65d3dacbce7e05b3eb12b1ebc33b00f687f390fd65cbc88c3d652a08eb1dab96275b8106d3a3b42ca5ef148f04d100eef376dc4f65453b680e1998dc8a4b9c6ce13145e74ca3b211558432b1007f27850c33ab712df0f171519de24c1e19ade4f2daae4c03d84997bfbb4699b0ea051bdeabde7f682aa36e036c4fec444460680f774d526ca80fa5003a5502b7ad8b6f46ed465dd205539bdd9e3c36f468775de7ec7904aaeb133264a149134930074f3a42a245932706b5525f4ff7c082337162700efbd8d1256d660497d651a5ecfadaf4024ccac4f504931da05f2ff85aaabbdfea380580b0b5fe05ec8bde744e6c34a44e013600fa184025cb8ec5bbc6a8fee583433b261a05f869f80bde0a3e6771e449b805c9e63993fd4a175b8d69acfab8e9a23e35b9f391d520400639d3d427a54ebf20bea2a5b64561bb33bba96e198e6e5aea8bc6b5865630a9202f9e77cd95631fed3f0eee78a188c88ebbcf1e7fdc47d688089d4439725bb9d9c1467c0e277f1908ca17f1b75a82980709892755381a502415b1341655130c3e9471b7f6f75209b4ac9262b1398175c6deaec80650b72d17cdeac8733587b8383ea2b306a99d748c446f4a9542878289f685b456c519042e40c6b2bcbc34e0a13bf0c6500ae2600b5ca8c6dbbf71cf8c02e125a60df66fa133f96142cbbed252bd156c7807347c8aa149b223118ff89698b90c00f5ea43e4e1acc52d7424aeadea17a7a5b3da5c4a4f9282d730e0f5f077cefcb14cfabea778d29be61b818a0e291e97db1dfd6a0edcbb368a4bf5f01c766571e01a28b79dfbfe73e528e11ca6f99ca799eb41f07e92c2220df2d4af96b906c7a8c7159983c64ca2d484e492da652effffcff685acb1e5cbd7ee65851d1e2ed04a454c7eb0333fb43b510ddc3c99ee3de8bb2126bdd05b3511c13fb53b699b5a336b93d6266904aef4b2ab289ab7be12da01b14c4c12dafd4e38ba1a10637b5de69a1081396bea74e89ccd27bad2ea0bb7a1633776482dc0ae80ca67e442b756e9cf869830ca814afaf9f0909db858d353d4c213bb0f5007cb82ad4d7cb97c53fd22886fd8812d421a2e03edbbd43e7d55dec18f39dd46046eeeeed96cfc2be3a709b1e41bdc57be03adac7d176dc29c703864221d471c08124dacf580b8afa43dad1980442688ae089141639b1566adca153e587eda58dad76f139b13aa416286f52aa2779f8967e24e49d7523ca65839c987c98e1eddb6d9551d8c96ffcf3313bfc41785fb4766f4b4e5bb35e26928165873096458d8a244a59a893bcadb80866ea0f1bde828de95925a96263a667ed50f35ef5a7f88cb76d50848c169b90280790f9f648bea7a67b7210ecb7976d3f8c8dcffd9a3164d58fe67118dbd5b33c5ca6d51bd2994f2ae63e1381a66112036acc523e01fb819d32f2f60798498f62be7499934cc459f9ea4781900612ec8bca75bd68f34baddf04a7b317c68dd6348c7dce714334bb07f45178dc804b678920c855aa6d45e4de76025a99e37008bf177ec5adc27dc6431380f368de3b96ff0d4967c11ddce2bfdce9385e8a78fb149ba9ba6a74f4e22777dcc723419a02c9cbaf7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2024/12/05/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/12/05/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h1 id="1-面向对象和面向过程"><a href="#1-面向对象和面向过程" class="headerlink" title="1. 面向对象和面向过程"></a>1. 面向对象和面向过程</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><h2 id="1-2-面向对象优点"><a href="#1-2-面向对象优点" class="headerlink" title="1.2 面向对象优点"></a>1.2 面向对象优点</h2><ul><li><strong>易维护</strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。</li><li><strong>易复用</strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</li><li><strong>易扩展</strong>：模块化设计使得系统扩展变得更加容易和灵活。</li></ul><h1 id="2-面向对象三大特征"><a href="#2-面向对象三大特征" class="headerlink" title="2. 面向对象三大特征"></a>2. 面向对象三大特征</h1><h2 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h2><p>将对象的属性隐藏在对象内部，不允许外部对象直接访问对象内部的信息，但可以通过这个对象提供的方法操作属性。</p><h2 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h2><p>继承是在已存在的类的定义作为基础创建新类，新类可以增加新的数据和功能，也可以使用父类功能。</p><p>注意：</p><ul><li>子类拥有父类所有属性和方法（包括私有属性和方法），但是不能访问父类的私有属性和方法。</li></ul><h2 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h2><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>多态特点：</p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定</li><li>多态不能调用“只在子类存在但在父类不存在”的方法</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法</li></ul><h1 id="3-接口和抽象类"><a href="#3-接口和抽象类" class="headerlink" title="3. 接口和抽象类"></a>3. 接口和抽象类</h1><h2 id="3-1-共同点"><a href="#3-1-共同点" class="headerlink" title="3.1 共同点"></a>3.1 共同点</h2><ul><li>实例化：接口和抽象类都不能直接实例化，只能被实现或继承后才能创建具体的对象。</li><li>抽象方法：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</li></ul><h2 id="3-2-不同点"><a href="#3-2-不同点" class="headerlink" title="3.2 不同点"></a>3.2 不同点</h2><ul><li>设计目的：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>继承和实现：类只能单继承，接口可以多继承。同时一个类可以实现多个接口。</li><li>成员变量：接口中的成员变量只能是public static final类型，不能被修改且必须有初始值。抽象类就没有这个限制。</li><li>方法：JAVA8之前，接口的方法只能是方法声明。JAVA8起，可以在接口中定义default方法和static方法。JAVA9起，接口可以包含private方法。</li></ul><h1 id="4-深拷贝，浅拷贝，引用拷贝"><a href="#4-深拷贝，浅拷贝，引用拷贝" class="headerlink" title="4. 深拷贝，浅拷贝，引用拷贝"></a>4. 深拷贝，浅拷贝，引用拷贝</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><ul><li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li>引用拷贝：新开一个引用指向需要拷贝的对象。</li></ul><p>拷贝实现可以实现Cloneable接口中的clone方法。</p><h2 id="4-2-比较"><a href="#4-2-比较" class="headerlink" title="4.2 比较"></a>4.2 比较</h2><p><img src="/2024/12/05/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/image_PyFqFWSnD2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年12月3日</title>
      <link href="/2024/12/03/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024-12-03/"/>
      <url>/2024/12/03/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024-12-03/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="2be62a6913000b75ac770b39bdf7b4d4ba64eee5acb29b3998c1306c9c27b748">e7fd074ae8bba43b23a7da116a4a69c6050d108c6e8e69e570f7fcaba4216070e04c383878af712aabb2e5efe0f99381759308bebd2386ca7d40f17c9b4cdda028793e3c2a7c947de250f6a60d953c9897e41f7ee1288d5bf3eed0282f331e44aca3a5e2f16090d0909381eabee449e4f665f37583a995705439dbd3e697cf4c8718f5b3b4d63a1dd52d74445878f4fa1baec4c707f8689be3e7b7a3f39d277c17c402e9cc577301e13223d7fe864bbca47daa45c4f63537fb49bf9438656c53e1253f17686d51b19f576cdabe6e695e1eb35a0b71f90cae9769d8c99db21450e78b773f1d28070df3f5266540bd0d5fec94415cdc6af562d190428f59a602c6fe928e25a5f068933af522d69f55979497d2cf5166aa6f68ea19679714ab25f1c9153ce7b465caf941f6ed8b28206e4b3f42d88bd7d4548d8a89da68c5bc76733006097961b22038351e5f6c0ae1e743048b8e0b27fe5f20b7049fa6a87a24435c005370c4fd0f45951ca8b129f7ca6bcede2a2ef50763caefb46f7a85a8341758f7b89b09d54527ac9d3ecc2557ce82a88ca5c762b1b5b2829d5e473704a01fef682e22e3aeed9e0d84a5f4e62e92881cc43f93bd18c4eb426d1d99be0989c8059a4a22991057903320bebbd038b4f5c9d316d8f678bc7ddc374a463a3a310477491806e7aeaaf6e1040a9f279bad4149ffa7e54c57d195891fd1b40031cdc11f562fe9597e34ef4c4c9c44ba69cc77e30beee8b4ce4f05a4ecda2bb4595e40ca4429c8f5aba6dcd5d6461db5978e6c8a406e2b65a0806450ebc6f946d36d35b57153d9cadf3e94d3d6471d048d6c8feeffa1d68f7cd7794a69c6c38cb0adaddddd14da3bf1067dce5e8ba82a4c981af6f315aa1ac3676e6c8a7644a6dbaa1b4f8df6b0a0d3beb3e55bf869b077266b3dd3d393786194cbeeae3d83a81ec54db8be484078aca3e274d55b1b7a4b4634d76578a82ebda887113708cc50343cefb7ecf4afd1e02b4b60fb4fe935d769a790008993ac97868b343c6ddb0064f0a2a96cc5be64eaa8a0d1a8d7eb0ed18703bc0786ae411bd29ac610d8a328e677235d7d6401107b1579dc6f4e8a7acc0ae011f74406f499327e3502b1e072cf843c9466c4500f79d1e57d83ff1dea4154b5d12300983c69c3991b7eb4cc21439861e307eeabc8e25764136fb85782bf5161e0ffaa1a0ac133bd4d514481324c328bfa31d0de9b41b6c496522de15e142c8628df0e9127dc1b6f465cbe14f8039f11a6bba42cd97f584d6523babd1a07bfb5275b1df647bd8f88e20344080ffcb30e65b61cad5fbcb6d89950f7858a948cbea91306055842da0c672992bfed6707b4b355527e0ca987522019eb030bf4f4039a4280725beab491e43bbfe70299ce382f7261e1bfb4d174ff0cacebdf613b6e3afaa26d6f8077d5bb3232eb9a831eb2fcafa03892f4495958313ab3470332bbfa20dd05bc19710167c594c66870e7e42dece793b9f84fce9731f142e9614dc81707d31b99255e17a78cc40c5b911f8563cf15218418ce77843f136ecd9584ed8e811d2ff53ed550385654aabef478bbe8827a45a7cc61c394cf33e37756b89f69188f673f54f7560e3bc316c0ab7a43ea139e2fe61a70febeb17eea37dbd4218833cd9c08e4a91bc66dd980a8ddc506943f952693d9ddf0d23197111a922c201e6cec921a50fe3a620fd4e5b53f277056095d19daf3d7f6975a2e86501baa3b5733e4b162433ec25b6d96cf4eb12d3bd1f105188ab8c041edeaa876b91354665c6144dbe66a67443c4199e2fb012ff24ca8f6d3d35f3f8cebcc46e4e889fb912fccf3d6a1138588b9e1720bdc9982befb169325368a353c7f204f791cfcbacf6418a8dddea5e62ddda4c9cd568db0978c4580a8ddafcf5594bbd8563eb9fb48b30c441b054c6c83f9453adfe0bdf68d0227e6ef3d455776ecd1c642536e55257965b06ef489f918513769e50f795b15</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
            <tag> 每日记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基本数据类型</title>
      <link href="/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h1 id="1-包装类型"><a href="#1-包装类型" class="headerlink" title="1. 包装类型"></a>1. 包装类型</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>Java 的包装类型（Wrapper Class）是对基本数据类型的对象表示，用于将基本数据类型（如 <code>int</code>、<code>double</code>）包装为类对象。包装类存在的主要目的是使基本数据类型能够与 Java 的集合框架（如 <code>ArrayList</code>）等只能操作对象的API兼容。</p><h2 id="1-2-基本类型和包装类型的区别"><a href="#1-2-基本类型和包装类型的区别" class="headerlink" title="1.2 基本类型和包装类型的区别"></a>1.2 基本类型和包装类型的区别</h2><ul><li>用途：定义一些常用变量或局部变量会使用基本类型；在对象属性，方法参数中会使用包装类型，同时包装类型可用于泛型。</li><li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，存储在堆中。</li><li>占用空间：基本数据类型占用空间小。</li><li>默认值：成员变量包装类不赋值就是null，基本数据类型有默认值。</li><li>比较方式：基本数据类型中，&#x3D;&#x3D;比较的是数值是否相同；对于包装类型来说，&#x3D;&#x3D;比较的是对象的内存地址，equals可以比较数值大小。</li></ul><h2 id="1-3-包装类型的缓存机制"><a href="#1-3-包装类型的缓存机制" class="headerlink" title="1.3 包装类型的缓存机制"></a>1.3 包装类型的缓存机制</h2><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><h2 id="1-4-自动装箱与拆箱"><a href="#1-4-自动装箱与拆箱" class="headerlink" title="1.4 自动装箱与拆箱"></a>1.4 自动装箱与拆箱</h2><h3 id="1-4-1-定义"><a href="#1-4-1-定义" class="headerlink" title="1.4.1 定义"></a>1.4.1 定义</h3><p>自动装箱：将基本数据类型转换为对应的包装类对象。</p><p>自动拆箱：将包装类对象自动转换为对应的基本数据类型。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2-综合理解装箱和包装类缓存机制"><a href="#1-4-2-综合理解装箱和包装类缓存机制" class="headerlink" title="1.4.2 综合理解装箱和包装类缓存机制"></a>1.4.2 综合理解装箱和包装类缓存机制</h3><p>下面我们来看一个问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。</p><p>下面是另一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">// true, 因为值在缓存范围内（-128 到 127）</span></span><br><span class="line">System.out.println(a.equals(b));  <span class="comment">// true, 比较值</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);  <span class="comment">// false, 超出缓存范围</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-BigDecimal"><a href="#2-BigDecimal" class="headerlink" title="2. BigDecimal"></a>2. BigDecimal</h1><h2 id="2-1-为什么浮点数运算的时候会有精度丢失的风险"><a href="#2-1-为什么浮点数运算的时候会有精度丢失的风险" class="headerlink" title="2.1 为什么浮点数运算的时候会有精度丢失的风险"></a>2.1 为什么浮点数运算的时候会有精度丢失的风险</h2><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h2 id="2-2-如何解决这个问题"><a href="#2-2-如何解决这个问题" class="headerlink" title="2.2 如何解决这个问题"></a>2.2 如何解决这个问题</h2><p>使用BigDecimal，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(c);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.2 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.20 */</span></span><br><span class="line"><span class="comment">// 比较内容，不是比较值</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* false */</span></span><br><span class="line"><span class="comment">// 比较值相等用相等compareTo，相等返回0</span></span><br><span class="line">System.out.println(<span class="number">0</span> == x.compareTo(y)); <span class="comment">/* true */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BigDecimal 是以字符串或整数形式存储的，所有运算都遵循十进制规则。</p><h1 id="3-超过long整型数据应该如何表示"><a href="#3-超过long整型数据应该如何表示" class="headerlink" title="3. 超过long整型数据应该如何表示"></a>3. 超过long整型数据应该如何表示</h1><p>使用BigInteger，<code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java自定义注解</title>
      <link href="/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="公共字段填充"><a href="#公共字段填充" class="headerlink" title="公共字段填充"></a>公共字段填充</h1><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p>我们在update和insert操作时需要修改创建时间，修改时间，修改人id，且这几种属性都属于公共属性，即所有的表都含有这个属性，如果通过service操作会显得非常繁琐，所以我们使用自定义注解的方式完成。</p><h1 id="2-自定义注解AtuoFill"><a href="#2-自定义注解AtuoFill" class="headerlink" title="2. 自定义注解AtuoFill"></a>2. 自定义注解AtuoFill</h1><p>自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法。自定义注解前要写上两个注解：</p><ul><li>一个是@Target(ElementType.METHOD)，这个注解用来指定当前注解只能加在方法上。</li><li>另一个注解是@Retention(RetentionPolicy.RUNTIME)，这个注解用来指定当前注解在什么阶段被保留，这里表示注解在运行时会被 JVM 保留</li></ul><p>这里的value是注解的一个属性，它的作用是接收一个 OperationType 类型的值，该值用来表示操作的类型（例如 INSERT 或 UPDATE）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>     <span class="comment">//指定当前注解只能加在方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>     <span class="comment">//指定当前注解的生命周期，这里表示注解在运行时会被 JVM 保留</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    <span class="comment">//指定数据库操作类型: UPDATE, INSERT</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-定义切面类"><a href="#3-定义切面类" class="headerlink" title="3. 定义切面类"></a>3. 定义切面类</h1><p>因为要想实现自动填充方法，我们就需要在程序insert&#x2F;update前拦截这个mapper方法，并进行相关操作，这时就用到了切面编程的相关思想。</p><h2 id="3-1-切面类"><a href="#3-1-切面类" class="headerlink" title="3.1 切面类"></a>3.1 切面类</h2><p>声明一个类为切面类，切面类可以包含：</p><ul><li><strong>通知（Advice）</strong>：在程序执行的特定点（切点）上执行的代码。</li><li><strong>切点（Pointcut）</strong>：定义在哪些连接点上执行通知。</li><li><strong>引入（Introduction）</strong>：向目标类添加新的方法或属性。</li></ul><p>简单来说，切点的目的是告诉这个切面类哪些方法可以拦截；通知是拦截前&#x2F;后需要执行的操作，所以又可以分为前置通知，后置通知，返回通知，。</p><ul><li><strong>前置通知@Before</strong>：在目标方法执行之前执行的通知。用于在方法执行前进行准备工作，如参数校验、权限检查等。</li><li><strong>后置通知@After</strong>：在目标方法执行之后执行的通知，不管目标方法是否抛出异常。用于执行清理操作，如释放资源等。</li><li><strong>返回通知@AfterReturning</strong>：在目标方法正常执行完毕后执行的通知，且能够访问目标方法的返回值。用于在方法执行完后对返回结果进行处理，如日志记录、返回值的修改等。</li><li><strong>异常通知@AfterThrowing</strong>：当目标方法抛出异常时执行的通知。用于处理异常，比如日志记录、异常处理等。</li><li><strong>环绕通知（@Around）</strong>：包围目标方法执行的通知，可以控制目标方法的执行，甚至可以选择不执行目标方法。用于在方法执行前后加入自定义逻辑，例如：事务管理、性能统计等。它是最强大的通知类型，可以访问方法的参数、返回值，还可以控制目标方法是否执行。</li></ul><h2 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h2><h3 id="3-2-1-获取数据库操作类型"><a href="#3-2-1-获取数据库操作类型" class="headerlink" title="3.2.1 获取数据库操作类型"></a>3.2.1 获取数据库操作类型</h3><p>首先需要获得当前被拦截方法的数据库操作类型insert&#x2F;update，这里使用了反射的知识，joinPoint参数是被拦截的方法的信息，通过使用joinPoint，我们可以获得被拦截的方法的具体参数等信息。</p><p>我们使用joinPoint.getSignature()获得方法签名对象，但是signature是父类，其中没有获得方法参数的具体实现，所以我们要将他转化为子类MethodSignature，子类重写了父类方法，可以获得被拦截的方法信息。</p><p>再通过getAnnotation可以获得注解对象，同时调用注解对象的value属性就可以获得操作类型是insert还是update了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// joinPoint为拦截时传入的参数</span></span><br><span class="line">        log.info(<span class="string">&quot;开始进行公共字段的自动填充...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前被拦截方法的数据库操作类型</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();     <span class="comment">//方法签名对象</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);        <span class="comment">//获得方法上的注解对象</span></span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value();     <span class="comment">//获得数据库操作类型</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-获取当前被拦截的方法参数（实体对象）"><a href="#3-2-2-获取当前被拦截的方法参数（实体对象）" class="headerlink" title="3.2.2 获取当前被拦截的方法参数（实体对象）"></a>3.2.2 获取当前被拦截的方法参数（实体对象）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前被拦截的方法参数（实体对象）</span></span><br><span class="line">Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="keyword">if</span>(args == <span class="literal">null</span> || args.length == <span class="number">0</span>) &#123;      <span class="comment">//如果没有参数，返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>];    <span class="comment">//得到第一个参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-3-准备数据"><a href="#3-2-3-准备数据" class="headerlink" title="3.2.3 准备数据"></a>3.2.3 准备数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备赋值的数据</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-4-赋值"><a href="#3-2-4-赋值" class="headerlink" title="3.2.4 赋值"></a>3.2.4 赋值</h3><p>先使用entity反射获得方法，再通过invoke去使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据当前不同操作类型，为对应的属性通过反射来赋值</span></span><br><span class="line">        <span class="keyword">if</span>(operationType == OperationType.INSERT) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setCreateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setCreateUser&quot;</span>, Long.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, Long.class);</span><br><span class="line"></span><br><span class="line">                setCreateTime.invoke(entity, localDateTime);</span><br><span class="line">                setUpdateTime.invoke(entity, localDateTime);</span><br><span class="line">                setCreateUser.invoke(entity, currentId);</span><br><span class="line">                setUpdateUser.invoke(entity, currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operationType == OperationType.UPDATE) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Method setCreateTime = entity.getClass().getDeclaredMethod(&quot;setCreateTime&quot;, LocalDateTime.class);</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="comment">//Method setCreateUser = entity.getClass().getDeclaredMethod(&quot;setCreateUser&quot;, Long.class);</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//setCreateTime.invoke(entity, localDateTime);</span></span><br><span class="line">                setUpdateTime.invoke(entity, localDateTime);</span><br><span class="line">                <span class="comment">//setCreateUser.invoke(entity, currentId);</span></span><br><span class="line">                setUpdateUser.invoke(entity, currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> 苍穹项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础概念与常识</title>
      <link href="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/"/>
      <url>/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h1><h1 id="1-JVM与JDK与JRE"><a href="#1-JVM与JDK与JRE" class="headerlink" title="1. JVM与JDK与JRE"></a>1. JVM与JDK与JRE</h1><h2 id="1-1-JVM"><a href="#1-1-JVM" class="headerlink" title="1.1 JVM"></a>1.1 JVM</h2><p>JVM是java虚拟机，是运行java字节码的虚拟机。JVM会针对不同的操作系统开发不同版本的JVM，目的是在不同操作系统上运行相同的字节码都会给出相同的结果。</p><p>同时，不同的编程语言都可以生成字节码，并运行在jvm上</p><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_I2PrrZf6yR.png"></p><h2 id="1-2-JDK"><a href="#1-2-JDK" class="headerlink" title="1.2 JDK"></a>1.2 JDK</h2><p>jdk全称为Java Development Kit，是java开发工具包。它包含了：JRE（java runtime environment），编译器javac和其他工具。</p><h2 id="1-3-JRE"><a href="#1-3-JRE" class="headerlink" title="1.3 JRE"></a>1.3 JRE</h2><p>jre是java运行已编译java程序的环境，主要包括：JVM，java基础类库。</p><h2 id="1-4-JDK和JRE的关系"><a href="#1-4-JDK和JRE的关系" class="headerlink" title="1.4 JDK和JRE的关系"></a>1.4 JDK和JRE的关系</h2><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_nYdCCkPCQa.png"></p><h1 id="2-字节码"><a href="#2-字节码" class="headerlink" title="2. 字节码"></a>2. 字节码</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>字节码就是java程序编译后生成的.class文件。字节码只面向JVM虚拟机。</p><h2 id="2-2-好处"><a href="#2-2-好处" class="headerlink" title="2.2 好处"></a>2.2 好处</h2><p>字节码只面向JVM虚拟机，不面向任何特定处理器。这样会在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><h2 id="2-3-java程序运行过程-x20"><a href="#2-3-java程序运行过程-x20" class="headerlink" title="2.3 java程序运行过程&#x20;"></a>2.3 java程序运行过程&#x20;</h2><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_l-yZMFDxNr.png"></p><h2 id="2-4-解释器与JIT"><a href="#2-4-解释器与JIT" class="headerlink" title="2.4 解释器与JIT"></a>2.4 解释器与JIT</h2><p>在.class文件到机器码这一步中，JVM首先加载字节码的文件，然后通过解释器逐行解释代码，这种逐行解释的方式较慢，所以引入了JIT（just in time）编译器，JIT属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>这里补充一下解释器和编译器的区别：</p><ul><li>编译器将字节码<strong>一次性翻译成完整的机器码</strong>。</li><li>解释器逐条将字节码翻译为机器码，再执行。</li></ul><p>从.class → 机器码这一过程可以看出，java既使用了编译器，又使用了解释器，所以java是编译与解释共存的语言。</p><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_1SrpaNkuzr.png"></p><h1 id="3-AOT"><a href="#3-AOT" class="headerlink" title="3. AOT"></a>3. AOT</h1><h2 id="3-1-AOT是什么"><a href="#3-1-AOT是什么" class="headerlink" title="3.1 AOT是什么"></a>3.1 AOT是什么</h2><p>AOT全称为ahead of time compilation，意思是在程序被执行前就将其编译成机器码，属于静态编译（类似于C++）</p><h2 id="3-2-AOT优点"><a href="#3-2-AOT优点" class="headerlink" title="3.2 AOT优点"></a>3.2 AOT优点</h2><p>AOT 的主要优势在于启动时间、内存占用和打包体积。</p><ul><li>AOT避免了JIT预热的开销，提高了java的启动速度。</li><li>减少内存占用：JIT和解释器都需要用字节码，而AOT模式在程序部署前就已经编译为本地机器码，不需要解释器和JIT编译器。</li><li>增强程序安全性：很难反编译。</li></ul><h2 id="3-3-AOT与JIT"><a href="#3-3-AOT与JIT" class="headerlink" title="3.3 AOT与JIT"></a>3.3 AOT与JIT</h2><p>AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理。而很多框架都要用到这些动态特性，如spring。</p><p>JIT具备更高的极限处理能力（JIT可以记录很多热点代码）</p><h1 id="4-java和C-区别"><a href="#4-java和C-区别" class="headerlink" title="4. java和C++区别"></a>4. java和C++区别</h1><ul><li>java中不提供指针访问内存，线程更加安全</li><li>java的类是单继承，C++的类可以多继承。但是java的接口可以多继承</li><li>java可以自动回收内存</li><li>C++支持方法重载和运算符重载，java只支持方法重载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
