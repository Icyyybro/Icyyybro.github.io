<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SparseDrive</title>
      <link href="/2025/02/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/sparseDrive/"/>
      <url>/2025/02/27/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/sparseDrive/</url>
      
        <content type="html"><![CDATA[<h1 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h1><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>完善的模块化自动驾驶系统被解耦为不同的独立任务，例如感知、预测和规划，遭受模块间信息丢失和错误累积的困扰。相比之下，端到端范式将多任务统一到一个完全可微的框架中。尽管端到端范式具有巨大的潜力，但现有方法的性能和效率都不令人满意，特别是在规划安全性方面。我们将此归因于计算成本高昂的BEV（鸟瞰图）特征以及预测和规划的直接设计。</p><p>为此，我们探讨了稀疏表示，并回顾了端到端自动驾驶的任务设计，提出了一个名为SparseDrive的新范式。具体来说，SparseDrive由对称稀疏感知模块和并行运动规划器组成。稀疏感知模块将检测、跟踪和在线映射以对称模型架构统一起来，学习驾驶场景的完全稀疏表示。对于运动预测和运动规划，我们回顾了这两个任务之间的巨大相似性，从而导致运动规划器的并行设计。基于这种将规划建模为多模态问题的并行设计，我们提出了一种分层规划选择策略，该策略结合了碰撞感知重核模块，以选择合理安全的轨迹作为最终的规划输出。</p><p>凭借如此有效的设计，SparseDrive在所有任务的性能上都大大超过了以前的最先进水平，同时实现了更高的训练和推理效率。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>传统自动驾驶系统的特点是任务按顺序模块化。虽然在解释和错误跟踪方面具有优势，但不可避免地会导致信息丢失和跨连续模块的累积错误，从而限制了系统的最佳性能潜力。</p><p>最近，端到端驱动范式成为一个很有前途的研究方向。这种模式将所有任务集成到一个整体模型中，并可以朝着规划的最终追求进行优化。然而，现有的方法在性能和效率方面都不令人满意。一方面，以前的方法依赖于计算昂贵的BEV特征。另一方面，直接的预测和规划设计限制了模型的性能。我们在图1a中将以前的方法总结为以bev为中心的范式。</p><p>为了充分利用端到端范式的潜力，我们回顾了现有方法的任务设计，并认为运动预测和规划之间的三个主要相似之处被忽视如下：</p><ul><li>在预测周围智能体和自我车辆的未来轨迹时，运动预测和规划应考虑道路主体之间的高阶双向交互[^1]。然而，以往的方法通常采用顺序设计进行运动预测和规划，忽略了自我车辆对周围agents的影响。</li><li>准确预测未来的轨迹需要语义信息来理解场景，需要几何信息来预测智能体的未来运动，这既适用于运动预测，也适用于规划。虽然这些信息是在上游感知任务中提取的，但在自我车辆中却被忽略了。</li><li>运动预测和规划都是具有固有不确定性的多模态问题，但以往的方法只能预测确定性轨迹进行规划。</li></ul><p><img src="/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/Drive/image_0HPwYaink8.png" alt="图1：各种端到端范例的比较。(image_0HPwYaink8.png)传统的策略，即BEV。(b)稀疏中心范式。(c) (a)和(b)的表现和效率比较。 图1：各种端到端范例的比较。(a)传统的策略，即BEV。(b)稀疏中心范式。(c) (a)和(b)的表现和效率比较。 " title="图1：各种端到端范例的比较。(a)传统的策略，即BEV。(b)稀疏中心范式。(c) (a)和(b)的表现和效率比较。 图1：各种端到端范例的比较。(a)传统的策略，即BEV。(b)稀疏中心范式。(c) (a)和(b)的表现和效率比较。 "></p><p>为此，我们提出了SparseDrive，这是一个以稀疏为中心的范例，如图1b所示。具体来说，SparseDrive由对称稀疏感知模块和并行运动规划器组成。使用解耦实例特征和几何锚作为一个实例（动态道路代理或静态地图元素）的完整表示，对称稀疏感知将检测、跟踪和在线映射任务与对称模型架构统一起来，学习一个完全稀疏的场景表示。</p><p>在并行运动规划中，首先从自我实例初始化模块获得一个语义和几何感知的自我实例。利用稀疏的自我实例和周围智能体实例，同时进行运动预测和规划，得到所有道路智能体的多模态轨迹。为保证规划的合理性和安全性，采用融合碰撞感知重核模块的分层规划选择策略，从多模态轨迹建议中选择最终规划轨迹。</p><p>通过以上有效的设计，SparseDrive释放了端到端自动驾驶的巨大潜力，如图1c所示。在没有附加功能的情况下，我们的基本模型SparseDrive-B大大降低了平均L2误差19.4% （0.58m vs. 0.72m）和碰撞率71.4% （0.06% vs 0.21%)。与之前的SOTA（最先进的）方法UniAD[15]相比，我们的小型模型SparseDrive-S在所有任务中都取得了卓越的性能，训练速度提高了7.2倍（20小时比144小时），推理速度提高了5.0倍（9.0 FPS比1.8 FPS）。</p><p>我们的主要工作贡献总结如下：</p><ul><li>我们探索了端到端自动驾驶的稀疏场景表示，并提出了一个以稀疏为中心的范式SparseDrive，该范式将多个任务与稀疏实例表示统一起来。</li><li>我们修正了运动预测和运动规划<a href="%E8%BF%90%E5%8A%A8%E9%A2%84%E6%B5%8B%E4%B8%BB%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%E9%A2%84%E6%B5%8B%E5%85%B6%E4%BB%96%E4%BA%A4%E9%80%9A%E5%8F%82%E4%B8%8E%E8%80%85%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%A1%8C%E4%B8%BA%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E5%AE%83%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E7%90%86%E8%A7%A3%E5%92%8C%E9%A2%84%E6%B5%8B%E8%B7%AF%E4%B8%8A%E5%85%B6%E4%BB%96%E5%8A%A8%E6%80%81%E7%9B%AE%E6%A0%87%EF%BC%88%E5%A6%82%E8%BD%A6%E8%BE%86%E3%80%81%E8%A1%8C%E4%BA%BA%E3%80%81%E8%87%AA%E8%A1%8C%E8%BD%A6%E7%AD%89%EF%BC%89%E7%9A%84%E6%9C%AA%E6%9D%A5%E8%BF%90%E5%8A%A8%E8%BD%A8%E8%BF%B9%E3%80%82">^2</a>之间的相似性，相应地导致了运动规划器的并行设计。为了提高规划性能，我们进一步提出了一种包含冲突感知重核模块的分层规划选择策略。</li><li>在具有挑战性的nuScenes基准测试中，SparseDrive在所有指标（尤其是安全关键指标碰撞率）方面都超过了以前的SOTA方法，同时保持了更高的训练和推理效率。</li></ul><h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h1><h2 id="2-1-Multi-view-3D-Detection（多视图三维检测）"><a href="#2-1-Multi-view-3D-Detection（多视图三维检测）" class="headerlink" title="2.1 Multi-view 3D Detection（多视图三维检测）"></a>2.1 Multi-view 3D Detection（多视图三维检测）</h2><p>多视角三维检测是保证自动驾驶系统安全运行的前提。LSS利用深度估计将图像特征提升到3D空间，并将特征拼合到BEV平面。后续工作将lift-splat操作应用到三维探测领域，在精度和效率方面都有了显著提高。一些研究预先定义了一组BEV查询，并将其投影到透视图中进行特征采样。另一项研究消除了对密集BEV特征的依赖。PETR系列引入了三维位置编码和全局关注来隐式学习视图变换。Sparse4D系列在3D空间中设置显式锚点，将其投影到图像视图中，以迭代的方式聚合局部特征并细化锚点。</p><h2 id="2-2-End-to-End-Tracking（端到端跟踪）"><a href="#2-2-End-to-End-Tracking（端到端跟踪）" class="headerlink" title="2.2 End-to-End Tracking（端到端跟踪）"></a>2.2 End-to-End Tracking（端到端跟踪）</h2><p>多目标跟踪（MOT）方法大多采用检测跟踪（tracking-by-detection）方式，依赖于数据关联等后处理。这样的流程不能充分利用神经网络的能力。受[2]中的对象查询的启发，一些作研究引入了跟踪查询，以流方式对跟踪实例进行建模。motor提出了tracklet-aware标签分配，这迫使轨迹查询持续检测相同的目标，并且存在检测与关联之间的冲突。Sparse4Dv3证明临时传播的实例已经具有身份一致性，并通过简单的ID分配过程实现了SOTA跟踪性能。</p><h2 id="2-3-Online-Mapping（在线地图）"><a href="#2-3-Online-Mapping（在线地图）" class="headerlink" title="2.3 Online Mapping（在线地图）"></a>2.3 Online Mapping（在线地图）</h2><p>由于制作高清地图的成本高，而且需要耗费大量人力，因此提出了在线地图作为高清地图的替代方案。HDMapNet组BEV语义分割与后处理，以获得矢量化的地图实例。VectorMapNet利用两级自回归变压器进行在线地图构建。MapTR将映射元素建模为等价置换的点集，避免了映射元素定义的模糊性。BeMapNet采用分段贝塞尔曲线来描述地图元素的细节。streamapnet引入了BEV融合和查询传播来进行时态建模。</p><h2 id="2-4-End-to-End-Motion-Prediction（端到端运动预测）"><a href="#2-4-End-to-End-Motion-Prediction（端到端运动预测）" class="headerlink" title="2.4 End-to-End Motion Prediction（端到端运动预测）"></a>2.4 End-to-End Motion Prediction（端到端运动预测）</h2><p>为了避免传统管道中的级联误差，提出了端到端运动预测方法。FaF使用单个卷积网络来预测当前和未来的边界框。internet更进一步，对高层次行为和长期轨迹进行了推理。PnPNet引入了一个在线跟踪模块来聚合运动预测的轨迹水平特征。</p><p>ViP3D采用代理查询进行跟踪和预测，以图像和高清地图为输入。PIP将人工标注的高清地图替换为局部矢量化地图。</p><h1 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h1><p><img src="/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/Drive/image_VgLMqDBmfK.png" alt="图2:SparseDrive的概述。SparseDrive首先将多视图图像编码成特征图，然后通过对称稀疏感知学习稀疏场景表示，最后以并行方式进行运动预测和规划。设计了一个实例内存队列用于时态建模。 图2:SparseDrive的概述。SparseDrive首先将多视图图像编码成特征图，然后通过对称稀疏感知学习稀疏场景表示，最后以并行方式进行运动预测和规划。设计了一个实例内存队列用于时态建模。 " title="图2:SparseDrive的概述。SparseDrive首先将多视图图像编码成特征图，然后通过对称稀疏感知学习稀疏场景表示，最后以并行方式进行运动预测和规划。设计了一个实例内存队列用于时态建模。 图2:SparseDrive的概述。SparseDrive首先将多视图图像编码成特征图，然后通过对称稀疏感知学习稀疏场景表示，最后以并行方式进行运动预测和规划。设计了一个实例内存队列用于时态建模。 "></p><h2 id="3-1-Overview"><a href="#3-1-Overview" class="headerlink" title="3.1 Overview"></a>3.1 Overview</h2><p>SparseDrive的总体框架如图2所示。具体来说，SparseDrive由图像编码器、对称稀疏感知和并行运动规划三部分组成。给定多视图图像，图像编码器首先将图像编码为多视图多尺度特征地图：</p><p>$$<br>I&#x3D;\left{I_{s} \in \mathbb{R}^{N \times C \times H_{s} \times W_{s}} \mid 1 \leq s \leq S\right}<br>$$</p><p>其中s为尺度数，N为摄像机视图数。在对称稀疏感知模块中，将特征映射I聚合为两组实例，学习驾驶场景的稀疏表示。这两组实例，分别代表周围的agents和地图元素，被馈送到并行运动规划器中与初始化的自车交互。运动规划器同时预测周围agents和自我车辆的多模态轨迹，并通过分层规划选择策略选择安全轨迹作为最终规划结果。</p><h2 id="3-2-Symmetric-Sparse-Perception（对称稀疏感知）"><a href="#3-2-Symmetric-Sparse-Perception（对称稀疏感知）" class="headerlink" title="3.2 Symmetric Sparse Perception（对称稀疏感知）"></a>3.2 Symmetric Sparse Perception（对称稀疏感知）</h2><p><img src="C:\Users\WYC\AppData\Local\Temp\Rar$DIa25780.6317\image\image_W3L7nE6Ida.png" alt="图3：对称稀疏感知的模型架构，在对称结构中统一了检测、跟踪和在线映射。 图3：对称稀疏感知的模型架构，在对称结构中统一了检测、跟踪和在线映射。 " title="图3：对称稀疏感知的模型架构，在对称结构中统一了检测、跟踪和在线映射。 图3：对称稀疏感知的模型架构，在对称结构中统一了检测、跟踪和在线映射。 "></p><p>如图3所示，稀疏感知模块的模型结构呈现出结构对称性，将检测、跟踪和在线映射统一在一起。</p><h3 id="3-2-1-稀疏检测"><a href="#3-2-1-稀疏检测" class="headerlink" title="3.2.1 稀疏检测"></a>3.2.1 稀疏检测</h3><p>稀疏检测：周围agents由一组实例特征$F_{d} \in \mathbb{R}^{N_{d} \times C}$和锚框$B_{d} \in \mathbb{R}^{N_{d} \times 11}$表示，其中Nd是锚点的数量，C是特征信道维度。每个锚框都有位置、尺寸、偏航角和速度的格式：</p><p>$$<br>{x, y, z, \ln w, \ln h, \ln l, \sin y a w, \cos y a w, v x, v y, v z}.<br>$$</p><p>稀疏检测分支由$N_{d e c}$个解码器组成，包括一个非时间解码器和$N_{d e c}-1$个时间解码器。每个解码器将特征图(feature map)I、实例特征(instance feature)Fd和锚框Bd作为输入，输出更新的实例特征和改进的锚框。非时间解码器以随机初始化的实例作为输入，而时间解码器的输入来自当前帧和历史帧。</p><p>具体来说，非时间解码器包括三个子模块：可变形聚合、前馈网络（FFN）和用于细化（调整锚库框）和分类的输出层。可变形聚合模块在锚框Bd周围生成固定或可学习的关键点，并将其投影到特征图I中以进行特征采样。实例特征Fd通过与采样特征求和来更新，并负责预测分类得分和输出层中锚框的偏移。</p><p>时间解码器有两个额外的多头注意层：上一帧和当前实例的时间实例之间的时间交叉attention，以及当前实例之间的self attention。在多头注意层中，锚箱被转化为高维锚嵌入$E_{d} \in \mathbb{R}^{N_{d} \times C}$，并用作位置编码。</p><h3 id="3-2-2-稀疏的在线地图"><a href="#3-2-2-稀疏的在线地图" class="headerlink" title="3.2.2 稀疏的在线地图"></a>3.2.2 稀疏的在线地图</h3><p>在线映射分支与检测分支共享相同的模型结构，但实例定义不同。对于静态地图元素，锚点被表示为具有Np个点的折线：</p><p>$$<br>\left{x_{0}, y_{0}, x_{1}, y_{1}, \ldots, x_{N_{p}-1}, y_{N_{p}-1}\right}<br>$$</p><p>然后，所有地图元素都可以用地图实例特征$F_{m} \in \mathbb{R}^{N_{m} \times C}$和锚折线$L_{m} \in \mathbb{R}^{N_{m} \times N_{p} \times 2}$，其中Nm是锚折线的数量。</p><h3 id="3-2-3-稀疏跟踪"><a href="#3-2-3-稀疏跟踪" class="headerlink" title="3.2.3 稀疏跟踪"></a>3.2.3 稀疏跟踪</h3><p>对于跟踪，我们遵循Sparse4Dv3的ID分配过程：一旦实例的检测置信度超过阈值Tthresh，它就会被锁定到目标上并分配一个ID，该ID在整个时间传播过程中保持不变。这种跟踪策略不需要任何跟踪约束，从而为稀疏感知模块提供了一种优雅而简单的对称设计。</p><h2 id="3-3-Parallel-Motion-Planner（运动规划器）"><a href="#3-3-Parallel-Motion-Planner（运动规划器）" class="headerlink" title="3.3 Parallel Motion Planner（运动规划器）"></a>3.3 Parallel Motion Planner（运动规划器）</h2><p><img src="/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/Drive/image_f9bgS904M_.png" alt="图4：并行运动规划器的模型结构，它同时执行运动预测和规划，并输出安全的规划轨迹。 图4：并行运动规划器的模型结构，它同时执行运动预测和规划，并输出安全的规划轨迹。 " title="图4：并行运动规划器的模型结构，它同时执行运动预测和规划，并输出安全的规划轨迹。 图4：并行运动规划器的模型结构，它同时执行运动预测和规划，并输出安全的规划轨迹。 "></p><p>对于自车锚点，位置、尺寸和偏航角可以直接设置，因为我们知道自我车辆的这些信息。对于速度，直接从地面真实速度初始化会导致自我状态泄漏<a href="%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%97%B6%EF%BC%8C%E6%A8%A1%E5%9E%8B%E5%8F%AA%E8%83%BD%E4%BB%8E%E7%82%B9%E4%BA%91%E5%92%8C%E5%9B%BE%E7%89%87%E4%B8%AD%E8%8E%B7%E5%BE%97%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E7%9F%A5%E9%81%93%E7%9C%9F%E5%AE%9E%E9%80%9F%E5%BA%A6%E3%80%82">^3</a>，如[27]所示。因此，我们增加了一个辅助任务来解码当前的自我状态EST，包括速度、加速度、角速度和转向角。在每一帧，我们使用上一帧的预测速度作为自我锚定速度的初始化。</p><h3 id="3-3-1-Spatial-Temporal-Interactions（时空相互作用）"><a href="#3-3-1-Spatial-Temporal-Interactions（时空相互作用）" class="headerlink" title="3.3.1 Spatial-Temporal Interactions（时空相互作用）"></a>3.3.1 Spatial-Temporal Interactions（时空相互作用）</h3><p>为了考虑所有道路代理之间的高级交互，我们将ego实例与周围的agents连接起来，得到agent级实例：</p><p>$$<br>F_{a}&#x3D;\operatorname{Concat}\left(F_{d}, F_{e}\right), B_{a}&#x3D;\operatorname{Concat}\left(B_{d}, B_{e}\right)<br>$$</p><p>由于自车是在没有时间线索的情况下初始化的，这对规划很重要，我们设计了一个大小为（Nd+1）×H的实例内存队列用于时间建模，H是存储的帧数。然后进行三种类型的交互来聚合时空上下文：agent-temporal cross-attention, agent-agent self-attention and agent-map cross-attention。</p><p>请注意，在稀疏感知模块的时间交叉注意中，当前帧的所有实例与所有时间帧的所有实例相互作用，我们称之为场景级交互。而对于这里的agent-temporal cross-attention，我们采用实例级交互，使每个实例都专注于自身的历史信息。</p><p>然后，我们预测了多模态轨迹$\tau_{m} \in \mathbb{R}^{N_{d} \times \mathcal{K}<em>{m} \times T</em>{m} \times 2}$，$\tau_{p} \in \mathbb{R}^{N_{c} \times \mathcal{K}<em>{p} \times T</em>{p} \times 2}$并为周围主体和自我车辆打分：$s_{m} \in \mathbb{R}^{N_{d} \times \mathcal{K}<em>{m}}$，$s</em>{p} \in \mathbb{R}^{N_{c m d} \times \mathcal{K}_{p}}$，Km和Kp是运动预测和规划的模式数量，Tm和Tp是运动预测和规划的未来时间戳数量，Ncmd是规划的驾驶命令数量。</p><h3 id="3-3-2-分层规划选择"><a href="#3-3-2-分层规划选择" class="headerlink" title="3.3.2 分层规划选择"></a>3.3.2 分层规划选择</h3><p>现在我们有了多模态规划轨迹建议，为了选择一个安全的轨迹$\tau_{p}^{*}$来遵循，我们设计了一个分层规划选择策略。首先，我们选择一个子集的轨迹建议$\tau_{p, c m d} \in \mathcal{K}<em>{p} \times T</em>{p} \times 2$，对应于高级命令cmd。然后，采用了一种新颖的碰撞感知重排序模块来确保安全。根据运动预测结果，我们可以评估每个规划轨迹提案的碰撞风险，对于碰撞概率较高的轨迹，我们降低了该轨迹的得分。在实践中，我们简单地将碰撞轨迹的分数设置为0。最后，我们选择得分最高的轨迹作为最终的规划输出。</p><h2 id="3-4-End-to-End-Learning"><a href="#3-4-End-to-End-Learning" class="headerlink" title="3.4 End-to-End Learning"></a>3.4 End-to-End Learning</h2><h3 id="3-4-1-Multi-stage-Training"><a href="#3-4-1-Multi-stage-Training" class="headerlink" title="3.4.1 Multi-stage Training"></a>3.4.1 Multi-stage Training</h3><p>多阶段培训。SparseDrive的训练分为两个阶段。</p><p>在第一阶段，我们从头开始训练对称稀疏感知模块来学习稀疏场景表示。</p><p>在阶段2中，稀疏感知模块和并行运动规划器在没有模型权重冻结的情况下一起训练，充分享受了端到端优化的好处。更多培训细节见附录B.4。</p><h3 id="3-4-2-Loss-Functions"><a href="#3-4-2-Loss-Functions" class="headerlink" title="3.4.2 Loss Functions"></a>3.4.2 Loss Functions</h3><p>损失函数包括四个任务的损失，每个任务的损失可以进一步分为分类损失和回归损失。对于多模态运动预测和规划任务，我们采用赢家通吃策略。对于规划，自我状态会有额外的回归损失。我们还引入了深度估计作为辅助任务，以提高感知模块的训练稳定性。端到端培训的总体损失函数为：</p><p>$$<br>\mathcal{L}&#x3D;\mathcal{L}<em>{\text {det }}+\mathcal{L}</em>{\text {map }}+\mathcal{L}<em>{\text {motion }}+\mathcal{L}</em>{\text {plan }}+\mathcal{L}_{\text {depth }}<br>$$</p><p>附录B.3中提供了有关损失函数的更多详细信息。</p><p>在计算完成后，我们将得到的坐标进行可视化处理，我们将三维视图转换为俯视图，并将物体中心投影在二维平面上，投影的结果如图3.3所示。</p><p>图3.3物体中心可视化</p><p>上图中，原点坐标（0，0）周围是白色的，这是因为我们以自车中心为原点建立坐标系，所以原点周围是自车的投影，不属于周围物体。同时，我们发现</p><p>$$<br>\begin{aligned}\\text{Planning L2} &#x3D; \frac{1}{T} \sum_{t&#x3D;1}^{T} \sqrt{(x_t^{\text{pred}} - x_t^{\text{gt}})^2 + (y_t^{\text{pred}} - y_t^{\text{gt}})^2}\\end{aligned}<br>$$</p><p><img src="/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/Drive/nuimages-schema_f86oOmkQAp.svg"></p><p>[^1]: 高阶交互（higher-order interactions）：指的是多个交通参与者之间的复杂相互影响，而不仅仅是考虑直接的单一影响。例如，某辆车的行驶决策可能不仅受前车的影响，还可能受到侧面或后方其他交通参与者的影响。</p><pre><code>双向交互（bidirectional interactions）：强调不仅仅要考虑自动驾驶车辆与其他交通参与者的交互，还要考虑其他交通参与者如何感知并反应自动驾驶车辆的行为。即，自动驾驶车辆与周围交通参与者之间的互动是相互的、动态的，而非单向的。</code></pre><pre><code>运动规划则是自动驾驶系统的决策部分，主要目的是根据当前的环境和目标，决定自动驾驶车辆的最优运动路径。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 论文精读 </category>
          
          <category> 端到端自动驾驶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 端到端自动驾驶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL：事务隔离级别</title>
      <link href="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><h1 id="1-事务特性"><a href="#1-事务特性" class="headerlink" title="1. 事务特性"></a>1. 事务特性</h1><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成。</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如A向B转账，数据库不会出现非法状态，如总金额丢失或多出。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB该如何保证这四个特性呢：</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h1 id="2-并行会引发的问题"><a href="#2-并行会引发的问题" class="headerlink" title="2. 并行会引发的问题"></a>2. 并行会引发的问题</h1><h2 id="2-1-脏读"><a href="#2-1-脏读" class="headerlink" title="2.1 脏读"></a>2.1 脏读</h2><p><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></p><p>例如：</p><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_Lw2X6QgsYj.png"></p><h2 id="2-2-不可重复读"><a href="#2-2-不可重复读" class="headerlink" title="2.2 不可重复读"></a>2.2 不可重复读</h2><p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_P-mkU_8Gli.png"></p><h2 id="2-3-幻读"><a href="#2-3-幻读" class="headerlink" title="2.3 幻读"></a>2.3 幻读</h2><p><strong>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了「幻读」现象。</strong></p><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_IB87TYWwCF.png"></p><h1 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3. 事务的隔离级别"></a>3. 事务的隔离级别</h1><p>上述三个现象的严重排序如下：</p><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_9D6X-z6Arm.png"></p><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低：</p><ul><li><strong>读未提交（</strong><em><strong>read uncommitted</strong></em><strong>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（</strong><em><strong>read committed</strong></em><strong>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（</strong><em><strong>repeatable read</strong></em><strong>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li>串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>按隔离水平高低排序如下：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/cce766a69dea725cd8f19b90db2d0430.png"></p><h2 id="3-1-可重复读"><a href="#3-1-可重复读" class="headerlink" title="3.1 可重复读"></a>3.1 可重复读</h2><p>MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（并不是彻底避免）。解决方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h2 id="3-2-四种隔离级别"><a href="#3-2-四种隔离级别" class="headerlink" title="3.2 四种隔离级别"></a>3.2 四种隔离级别</h2><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读已提交」和「可重复读」隔离级别的事务来说，它们是通过 <strong>Read View 来实现的，它们的区别在于创建 Read View 的时机不同，「读已提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</li></ul><h2 id="3-3-事务的启动"><a href="#3-3-事务的启动" class="headerlink" title="3.3 事务的启动"></a>3.3 事务的启动</h2><p>执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：</p><ul><li>第一种：begin&#x2F;start transaction 命令：执行了 begin&#x2F;start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机；</li><li>第二种：start transaction with consistent snapshot 命令；执行了 start transaction with consistent snapshot 命令，就会马上启动事务。</li></ul><h1 id="4-Read-View"><a href="#4-Read-View" class="headerlink" title="4. Read View"></a>4. Read View</h1><h2 id="4-1-Read-View构成"><a href="#4-1-Read-View构成" class="headerlink" title="4.1 Read View构成"></a>4.1 Read View构成</h2><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_5EYXMy6XgY.png"></p><ul><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li></ul><p>假设在账户余额表插入一条小林余额为 100 万的记录，然后我把这两个隐藏列也画出来，该记录的整个示意图如下：</p><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_24rG4OQ6QU.png"></p><p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_7MUyG4Ml_v.png"></p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务不可见。</li><li>如果记录的 trx_id 值在 Read View 的 <code>min_trx_id</code>和 <code>max_trx_id</code> 之间，需要判断 trx_id 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><h1 id="5-可重复读是如何工作的"><a href="#5-可重复读是如何工作的" class="headerlink" title="5. 可重复读是如何工作的"></a>5. 可重复读是如何工作的</h1><p>可重复读隔离级别是启动事务时生成一个 Read View，<strong>然后整个事务期间都在用这个 Read View</strong>。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_mYvgWlm_bp.png"></p><p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p><ul><li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li><li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li></ul><p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中</strong>的 min_trx_id 值（51）还小，<strong>这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p><p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log， 并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_QHhZDKXGPH.png"></p><p>然后事务 B 第二次去读取该记录，**发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，**则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，<strong>那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，</strong> 还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。<strong>所以，即使事物 A 将小林余额修改为 200 万并提交了事务，事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p><h1 id="6-读提交如何工作"><a href="#6-读提交如何工作" class="headerlink" title="6. 读提交如何工作"></a>6. 读提交如何工作</h1><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><p>那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。</p><ul><li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li><li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li></ul><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_JQ6GkBwhIw.png"></p><p><img src="/2025/01/22/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image_isz_7Qs6Mh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL：索引常见问题</title>
      <link href="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL：索引常见问题"><a href="#MySQL：索引常见问题" class="headerlink" title="MySQL：索引常见问题"></a>MySQL：索引常见问题</h1><h1 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1. 什么是索引"></a>1. 什么是索引</h1><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<strong>索引是数据的目录</strong>。</p><h1 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2. 索引分类"></a>2. 索引分类</h1><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><h2 id="2-1-按数据结构分类"><a href="#2-1-按数据结构分类" class="headerlink" title="2.1 按数据结构分类"></a>2.1 按数据结构分类</h2><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_DHUHByfKRL.png"></p><h3 id="2-1-1-索引的选择"><a href="#2-1-1-索引的选择" class="headerlink" title="2.1.1 索引的选择"></a>2.1.1 索引的选择</h3><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。</p><p><strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><h3 id="2-1-2-B-Tree索引结构特点"><a href="#2-1-2-B-Tree索引结构特点" class="headerlink" title="2.1.2 B+ Tree索引结构特点"></a>2.1.2 B+ Tree索引结构特点</h3><p>B+Tree的结构特点如下：</p><ul><li>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引。</li><li>每个节点里的数据是<strong>按主键顺序存放</strong>的。</li><li>每一层父节点的索引值都会出现在下层子节点的索引值中。</li><li>每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</li></ul><h3 id="2-1-3-聚簇索引和非聚簇索引区别"><a href="#2-1-3-聚簇索引和非聚簇索引区别" class="headerlink" title="2.1.3 聚簇索引和非聚簇索引区别"></a>2.1.3 聚簇索引和非聚簇索引区别</h3><p>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li><strong>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</strong></li></ul><h3 id="2-1-4-B-Tree优点"><a href="#2-1-4-B-Tree优点" class="headerlink" title="2.1.4 B+ Tree优点"></a>2.1.4 B+ Tree优点</h3><ol><li>B+Tree vs B Tree<ol><li>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更大，在相同的磁盘 I&#x2F;O 次数下，就能查询更多的节点。</li><li>B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找。</li></ol></li><li>B+ Tree vs 二叉树<ol><li>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为d 个。在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右。</li><li>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为<code>O(logN)</code>。</li></ol></li><li>B+ Tree vs hash<ol><li>Hash 表不适合做范围查询，它更适合做等值的查询。</li></ol></li></ol><h3 id="2-1-5-举例说明"><a href="#2-1-5-举例说明" class="headerlink" title="2.1.5 举例说明"></a>2.1.5 举例说明</h3><p>例如：</p><p>我新建一个表，如下图所示：</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_TZpCJOUNTb.png"></p><p>表中添加了这些数据：</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_bZYjjQireQ.png"></p><p>那么其聚簇索引的B+ Tree应该向下面一样（这里应该是双向链表，图中是单向链表）：<img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_Ii74Oocrq1.png"></p><p>其二级索引的B+Tree应该向下面一样：</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_qMCVQd-UXS.png"></p><p>如果我用 product_no 二级索引查询商品，如下查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> product_no <span class="operator">=</span> <span class="string">&#x27;0002&#x27;</span>;</span><br></pre></td></tr></table></figure><p>会先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。<strong>这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据</strong>。</p><h2 id="2-2-按物理存储分类"><a href="#2-2-按物理存储分类" class="headerlink" title="2.2 按物理存储分类"></a>2.2 按物理存储分类</h2><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p><p>这两个区别在前面也提到了：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li><strong>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</strong></li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p><h2 id="2-3-按字段特性分类"><a href="#2-3-按字段特性分类" class="headerlink" title="2.3 按字段特性分类"></a>2.3 按字段特性分类</h2><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><h3 id="2-3-1-主键索引"><a href="#2-3-1-主键索引" class="headerlink" title="2.3.1 主键索引"></a>2.3.1 主键索引</h3><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><p>在创建表时，创建主键索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (index_column_1) <span class="keyword">USING</span> BTREE</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="2-3-2-唯一索引"><a href="#2-3-2-唯一索引" class="headerlink" title="2.3.2 唯一索引"></a>2.3.2 唯一索引</h3><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p>在创建表时，创建唯一索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-3-普通索引"><a href="#2-3-3-普通索引" class="headerlink" title="2.3.3 普通索引"></a>2.3.3 普通索引</h3><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><p>在创建表时，创建普通索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name  (</span><br><span class="line">  ....</span><br><span class="line">  INDEX(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-4-前缀索引"><a href="#2-3-4-前缀索引" class="headerlink" title="2.3.4 前缀索引"></a>2.3.4 前缀索引</h3><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><p>在创建表时，创建前缀索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    column_list,</span><br><span class="line">    INDEX(column_name(length))</span><br><span class="line">); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-4-按字段个数分类"><a href="#2-4-按字段个数分类" class="headerlink" title="2.4 按字段个数分类"></a>2.4 按字段个数分类</h2><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引；</li><li>建立在多列上的索引称为联合索引；</li></ul><h3 id="2-4-1-联合索引"><a href="#2-4-1-联合索引" class="headerlink" title="2.4.1 联合索引"></a>2.4.1 联合索引</h3><p>通过将多个字段组合成一个索引，该索引就被称为联合索引。比如，将商品表中的 product_no 和 name 字段组合成联合索引<code>(product_no, name)</code>，创建联合索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure><p>联合索引<code>(product_no, name)</code> 的 B+Tree 示意图如下（叶子节点之间应该是双向链表）：</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_qgiyVIF86L.png"></p><p>最左匹配原则：联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</p><h3 id="2-4-2-举例"><a href="#2-4-2-举例" class="headerlink" title="2.4.2 举例"></a>2.4.2 举例</h3><p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>上面这些查询条件之所以会失效，是因为<code>(a, b, c)</code> 联合索引，是先按 a 排序在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong></p><h3 id="2-4-3-联合索引的范围查询"><a href="#2-4-3-联合索引的范围查询" class="headerlink" title="2.4.3 联合索引的范围查询"></a>2.4.3 联合索引的范围查询</h3><p>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p><p>例如，select * from t_table where a &gt; 1 and b &#x3D; 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p><p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a &gt; 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a &gt; 1 条件的第一条记录，但是a&gt;1时的b字段是无序的，所以<strong>这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引</strong>。</p><p>但是注意，并不是所有的范围查询都会有部分字段无法使用联合索引。</p><p>例如，<code>select * from t_table where a &gt;= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p><p>虽然在符合 a&gt;&#x3D; 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，<strong>但是对于符合 a &#x3D; 1 的二级索引记录的范围里，b 字段的值是「有序」的。</strong> 于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b &#x3D; 2 条件减少需要扫描的二级索引记录范围。所以，<strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><h3 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4 总结"></a>2.4.4 总结</h3><p>**联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。** 注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。</p><h3 id="2-4-5-索引下推优化"><a href="#2-4-5-索引下推优化" class="headerlink" title="2.4.5 索引下推优化"></a>2.4.5 索引下推优化</h3><p>现在我们知道，对于联合索引（a, b），在执行<code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><p>MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p><h3 id="2-4-6-索引区分度"><a href="#2-4-6-索引区分度" class="headerlink" title="2.4.6 索引区分度"></a>2.4.6 索引区分度</h3><p>实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><p>区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：</p><p>$$<br>区分度 &#x3D;\frac{\operatorname{distinct}(\operatorname{column})}{\operatorname{count}(*)}<br>$$</p><p>比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。</p><p>注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</p><h1 id="3-什么时候需要-不需要索引"><a href="#3-什么时候需要-不需要索引" class="headerlink" title="3. 什么时候需要&#x2F;不需要索引"></a>3. 什么时候需要&#x2F;不需要索引</h1><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><h2 id="3-1-什么时候适用索引"><a href="#3-1-什么时候适用索引" class="headerlink" title="3.1 什么时候适用索引"></a>3.1 什么时候适用索引</h2><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><h2 id="3-2-什么时候不需要创建索引"><a href="#3-2-什么时候不需要创建索引" class="headerlink" title="3.2 什么时候不需要创建索引"></a>3.2 什么时候不需要创建索引</h2><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女。</li><li>表数据太少的时候，不需要创建索引</li><li>经常更新的字段不用创建索引</li></ul><h2 id="3-3-优化索引的方法"><a href="#3-3-优化索引的方法" class="headerlink" title="3.3 优化索引的方法"></a>3.3 优化索引的方法</h2><h3 id="3-3-1-前缀索引优化"><a href="#3-3-1-前缀索引优化" class="headerlink" title="3.3.1 前缀索引优化"></a>3.3.1 前缀索引优化</h3><p>使用某个字段中字符串的前几个字符建立索引，使用前缀索引是为了减小索引字段大小。</p><h3 id="3-3-2-覆盖索引优化"><a href="#3-3-2-覆盖索引优化" class="headerlink" title="3.3.2 覆盖索引优化"></a>3.3.2 覆盖索引优化</h3><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。</p><h3 id="3-3-3-主键索引自增"><a href="#3-3-3-主键索引自增" class="headerlink" title="3.3.3 主键索引自增"></a>3.3.3 主键索引自增</h3><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。</p><h3 id="3-3-4-索引最好设置为NOT-NULL"><a href="#3-3-4-索引最好设置为NOT-NULL" class="headerlink" title="3.3.4 索引最好设置为NOT NULL"></a>3.3.4 索引最好设置为NOT NULL</h3><p>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</p><p>NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>，如下图的紫色部分：</p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_VRRKABLu2w.png"></p><h3 id="3-3-5-防止索引失效"><a href="#3-3-5-防止索引失效" class="headerlink" title="3.3.5 防止索引失效"></a>3.3.5 防止索引失效</h3><p>之后会说</p><h1 id="4-本章总结"><a href="#4-本章总结" class="headerlink" title="4. 本章总结"></a>4. 本章总结</h1><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_ZWd3UCKZzs.png"></p><p><img src="/2025/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/image_xPU7RKZ4bp.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年12月7日</title>
      <link href="/2024/12/07/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024%E5%B9%B412%E6%9C%887%E6%97%A5/"/>
      <url>/2024/12/07/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024%E5%B9%B412%E6%9C%887%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b9c733d36aacfa30df40d063d0713a557c171bf68756786dcaa1caafabd73e7">e7fd074ae8bba43b23a7da116a4a69c676530e99fe5e6995f7e4543f56bda66d5db46ece69d2796be3598d7eb70f7836f8d5ea82220955a4632e2fa0017c438e8292704cad1205ace0ffaa328e18808fc444b620242c8d76f8db5ea870d32c6d8b0631f36ef5710876c66c11b5029580186c8ac7b0ff74e43702b8b1edb2a02d4eb25e2801da2b06b842419a0967c566d4d3d3b952d46232c7dac3caaba5c7f495cb754ec053b5fc47ec40cdde4642e664658e7004f6332b4e179d2ec866365226f4749eea809d37593e4e05d2a6ffededc483d1c4af691a23e5a2863b3e1b5c1562bed735846aa80e389eca3d6fae95704f1ec662eabd49d55f651d19ca645ee26f1b66f7c6adfc91e0bfc8b61692a768bd13cc0aee160761fda05d8ac5d320f8880c9446775915baeb39cd5f7f175d06961b15f725388ead04fc54fbbbaf7030ce8d79eee88e0348a6faeb8a422c4291185c7ffda060da4dc803d54f38773ff66252b803e31f1a1cc3521d182eb8241bc10e947f1f494333dde0c38a478309ad1af90c561b06560adae74b195f13cf88cf2fe8e1ec5a4b621141f43fcdd6eea0d833368751bbe7f8e80e13d2b4c06f47384f6570bf20e3b0f3c2bba0046f4a198e91b55373defd028a074e40bc9d082db7867e27ee155f8d093b7943250142d80a71c2867362df7f2b58b8581cdfcfa714262792978e5e68f1406fd6f1a33079e333d95548f492cbe56b8d703ff9ff65b0994bed32737bdbd6c1b2c5996a6124eee1ae9f5cc2287204eda743ddaa5d46d8aa958f222b12f38e1de101b4f93e604c2bf7f3003ccfc7162627ff2a94016d25c0b461217c5ca89b35bd5ff72e80b42f73663160b5f09474865877fb3a92f95a4e6c0a50d0ad515681f419c9496ef6d29780481842afbb2eb25bd91aa198985e7561db36504d13cbe5986ed9f17dda9e32bc147680d9ab348a130efc17fa7e722c6ab070e4399be07005378ec537445db9b636e330a6e792f5c523b2600e7875c7ebbe3592c447964c3d7975c963b571681bd2555b66306889257a37cd0fa2d6149baedba86f9c408a4cf7c1f30bf07dcff9800aa86038aede99120838c47d8c58f9c0b35c96aa630f469cbddf1a6affa3c84a1e6a4a1d1cab1b1e1b4067939282b24ddb461521e29d2295af3d496d42c22b468c4fd925d1a133c32e8aec51ada07f824b3f1e6442a102baed990fea3792d7178b7934ed3a10b0119acec5ef32ae64a8716fd1b780b1383718a0d026ba6b642dfe6a3d36dd91652183d3f13478fa06af1e63dfcda15c788011ce92a48c26988e96879f2b33a22dd7536f51d8ef97a32d4e52834994e5227eb79573095f26ab150684f23ce4764f1dcc5adf9b9a72b4f905ca1c8cae466c5c89cb5b937eb05e322ff88e7e0e7fea02f4b42819820385f6d15efd2d88567f3b4a4e3b6cc74cb21cb401e44f4dd95f6315cfea14ad851055060656fb47983530f773fd9a0b0b0e13a5b2e2a00681ebd5320abe63ad261374c1146bc8353c77bb52f58bdcbde650f71dc6ec5a69710e68d2e9e8ad8bfca6aac9da5aebc12e75a31cd493a306e5e9081b697c82d5a7bddfc66a737e26a57324c3f43a369eb57b59b623171002061afc5ab260f0d9b5416aac7c3471ed2cf2307e9b0d7bd76fa8eb9e35a87a78e7853db3f3f8aa1d8d6cc40965eeb9d3d91aea73b12275008dfbeed14f644afcdf8b420758e3f0cb6fae6e2575ce39a824eb64bb4a97f3752e84eb2887607561e7129dc13b7b0b2215492441b42020ee35dff6d5ac1ff25f928333de6993d34442012527e53b17f44fcb4d0057791ea4a04cc6ebcfdbd8acce96c45b5df0549845263daff09b548215c633492339b5080c429c979bf0cae5f42f92f2ccedb53abe77500a6aa14c7f3e83199bf2412b3f1f2794aab99206d4e8496e91b061bd229fe61075e3d51340473a69741fa9764054073367cbe27788710e7fd025e3d39948b40a8d3a141d1322f88a81c063ba996bdf5e060272b475277ef89160766aa5d75d0b9379bc4fab2529c6482b8753514c758fb7d1ad5ba0e8bd84b00382026a69a0a39d82016fe6465ddf1436bd59f9fbb56783ac38ac770a47a6858e1ed8b96dcbc9f4b8d013478666ee6c9948ae249e2cfea630cfb46b249bc37676068c91581143fdec0a67d54c83d9f4fe96e0793fcea3af7372ce94b625c24e1c5c07984ec4e120871ec287d5a9af09227a7abfe815d501c6812460f3decf587dd0cf9304a70a9d4aa17df0186d34320ced6d7da76b8a1b57b3d7118fbe09f1e0f7a9d4024ec017bbbfebd2e57ed11ee4a31f73fe9cae69a31c4de8fdcd637f5bcc459834736b39abffa2c28e388bf3f79d2fa8c3d3b85ac0eb789499f9daa9847e60161373aa1a7ed59caf02b3ee004d8200d4739c4b0f91141b486dba42e4296497bc9aa687b61d542c141b4b4c857064bf4e5ad1ea640e4c33e46e92e0c46d05a2b8ceda5939e45a135673386a347ff996d5f6204d83c7bae0f77c134fdfd5c1d863d6ca11404ede61fd217cd9cec53c0ee7743e87c8e0250c2a61430a0788f74e054a442649a2e8e747d4391ab5447707f81a50fa54e64a0948afa96bf4673eaf3be3390524399d1b507226b980dc14e7c2eb7bd12d71508d9045777634635e73f18dd855db3346e3e7493ffc60aa4c8ea439ca7cbf01584b192167e24d30e090bd169793eb42e42fc93573b7c624cd43ab4c6c8b30a1700aac7743f7036f2f0bdeb168f2cc1052adcdc9e24049883a387e37b39198060e2f67c0e2b1ea7be4b5b531c8ead40ff56da80c593e913d545206d6d73e2d7086e16af568be46724303cf586f4893093ced1a1133a0084744dda6a62f93f6ce5b80176cbf854ce407532bf22403758a3791bc367c87d0d6e1d250facf7576c65560ca5ff949eb0c462537ce2fe50bb5b21976aa093f758baa2e4e3355ea7d47e3591b028af1a908dc50fa91dba67d45baeabe14c2a583f6c0933626ce0ca51728b63a5fd28987f0fa1dc8624966f186e84e14847aa56490ec0ffaa3befdfefc45fe856250075e5581ab268281ebd264ad0518b465da65d3dacbce7e05b3eb12b1ebc33b00f687f390fd65cbc88c3d652a08eb1dab96275b8106d3a3b42ca5ef148f04d100eef376dc4f65453b680e1998dc8a4b9c6ce13145e74ca3b211558432b1007f27850c33ab712df0f171519de24c1e19ade4f2daae4c03d84997bfbb4699b0ea051bdeabde7f682aa36e036c4fec444460680f774d526ca80fa5003a5502b7ad8b6f46ed465dd205539bdd9e3c36f468775de7ec7904aaeb133264a149134930074f3a42a245932706b5525f4ff7c082337162700efbd8d1256d660497d651a5ecfadaf4024ccac4f504931da05f2ff85aaabbdfea380580b0b5fe05ec8bde744e6c34a44e013600fa184025cb8ec5bbc6a8fee583433b261a05f869f80bde0a3e6771e449b805c9e63993fd4a175b8d69acfab8e9a23e35b9f391d520400639d3d427a54ebf20bea2a5b64561bb33bba96e198e6e5aea8bc6b5865630a9202f9e77cd95631fed3f0eee78a188c88ebbcf1e7fdc47d688089d4439725bb9d9c1467c0e277f1908ca17f1b75a82980709892755381a502415b1341655130c3e9471b7f6f75209b4ac9262b1398175c6deaec80650b72d17cdeac8733587b8383ea2b306a99d748c446f4a9542878289f685b456c519042e40c6b2bcbc34e0a13bf0c6500ae2600b5ca8c6dbbf71cf8c02e125a60df66fa133f96142cbbed252bd156c7807347c8aa149b223118ff89698b90c00f5ea43e4e1acc52d7424aeadea17a7a5b3da5c4a4f9282d730e0f5f077cefcb14cfabea778d29be61b818a0e291e97db1dfd6a0edcbb368a4bf5f01c766571e01a28b79dfbfe73e528e11ca6f99ca799eb41f07e92c2220df2d4af96b906c7a8c7159983c64ca2d484e492da652effffcff685acb1e5cbd7ee65851d1e2ed04a454c7eb0333fb43b510ddc3c99ee3de8bb2126bdd05b3511c13fb53b699b5a336b93d6266904aef4b2ab289ab7be12da01b14c4c12dafd4e38ba1a10637b5de69a1081396bea74e89ccd27bad2ea0bb7a1633776482dc0ae80ca67e442b756e9cf869830ca814afaf9f0909db858d353d4c213bb0f5007cb82ad4d7cb97c53fd22886fd8812d421a2e03edbbd43e7d55dec18f39dd46046eeeeed96cfc2be3a709b1e41bdc57be03adac7d176dc29c703864221d471c08124dacf580b8afa43dad1980442688ae089141639b1566adca153e587eda58dad76f139b13aa416286f52aa2779f8967e24e49d7523ca65839c987c98e1eddb6d9551d8c96ffcf3313bfc41785fb4766f4b4e5bb35e26928165873096458d8a244a59a893bcadb80866ea0f1bde828de95925a96263a667ed50f35ef5a7f88cb76d50848c169b90280790f9f648bea7a67b7210ecb7976d3f8c8dcffd9a3164d58fe67118dbd5b33c5ca6d51bd2994f2ae63e1381a66112036acc523e01fb819d32f2f60798498f62be7499934cc459f9ea4781900612ec8bca75bd68f34baddf04a7b317c68dd6348c7dce714334bb07f45178dc804b678920c855aa6d45e4de76025a99e37008bf177ec5adc27dc6431380f368de3b96ff0d4967c11ddce2bfdce9385e8a78fb149ba9ba6a74f4e22777dcc723419a02c9cbaf7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2024/12/05/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/12/05/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h1 id="1-面向对象和面向过程"><a href="#1-面向对象和面向过程" class="headerlink" title="1. 面向对象和面向过程"></a>1. 面向对象和面向过程</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><h2 id="1-2-面向对象优点"><a href="#1-2-面向对象优点" class="headerlink" title="1.2 面向对象优点"></a>1.2 面向对象优点</h2><ul><li><strong>易维护</strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。</li><li><strong>易复用</strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</li><li><strong>易扩展</strong>：模块化设计使得系统扩展变得更加容易和灵活。</li></ul><h1 id="2-面向对象三大特征"><a href="#2-面向对象三大特征" class="headerlink" title="2. 面向对象三大特征"></a>2. 面向对象三大特征</h1><h2 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h2><p>将对象的属性隐藏在对象内部，不允许外部对象直接访问对象内部的信息，但可以通过这个对象提供的方法操作属性。</p><h2 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h2><p>继承是在已存在的类的定义作为基础创建新类，新类可以增加新的数据和功能，也可以使用父类功能。</p><p>注意：</p><ul><li>子类拥有父类所有属性和方法（包括私有属性和方法），但是不能访问父类的私有属性和方法。</li></ul><h2 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h2><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>多态特点：</p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定</li><li>多态不能调用“只在子类存在但在父类不存在”的方法</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法</li></ul><h1 id="3-接口和抽象类"><a href="#3-接口和抽象类" class="headerlink" title="3. 接口和抽象类"></a>3. 接口和抽象类</h1><h2 id="3-1-共同点"><a href="#3-1-共同点" class="headerlink" title="3.1 共同点"></a>3.1 共同点</h2><ul><li>实例化：接口和抽象类都不能直接实例化，只能被实现或继承后才能创建具体的对象。</li><li>抽象方法：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</li></ul><h2 id="3-2-不同点"><a href="#3-2-不同点" class="headerlink" title="3.2 不同点"></a>3.2 不同点</h2><ul><li>设计目的：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>继承和实现：类只能单继承，接口可以多继承。同时一个类可以实现多个接口。</li><li>成员变量：接口中的成员变量只能是public static final类型，不能被修改且必须有初始值。抽象类就没有这个限制。</li><li>方法：JAVA8之前，接口的方法只能是方法声明。JAVA8起，可以在接口中定义default方法和static方法。JAVA9起，接口可以包含private方法。</li></ul><h1 id="4-深拷贝，浅拷贝，引用拷贝"><a href="#4-深拷贝，浅拷贝，引用拷贝" class="headerlink" title="4. 深拷贝，浅拷贝，引用拷贝"></a>4. 深拷贝，浅拷贝，引用拷贝</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><ul><li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li>引用拷贝：新开一个引用指向需要拷贝的对象。</li></ul><p>拷贝实现可以实现Cloneable接口中的clone方法。</p><h2 id="4-2-比较"><a href="#4-2-比较" class="headerlink" title="4.2 比较"></a>4.2 比较</h2><p><img src="/2024/12/05/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/image_PyFqFWSnD2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024年12月3日</title>
      <link href="/2024/12/03/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024-12-03/"/>
      <url>/2024/12/03/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024-12-03/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="2be62a6913000b75ac770b39bdf7b4d4ba64eee5acb29b3998c1306c9c27b748">e7fd074ae8bba43b23a7da116a4a69c6050d108c6e8e69e570f7fcaba4216070e04c383878af712aabb2e5efe0f99381759308bebd2386ca7d40f17c9b4cdda028793e3c2a7c947de250f6a60d953c9897e41f7ee1288d5bf3eed0282f331e44aca3a5e2f16090d0909381eabee449e4f665f37583a995705439dbd3e697cf4c8718f5b3b4d63a1dd52d74445878f4fa1baec4c707f8689be3e7b7a3f39d277c17c402e9cc577301e13223d7fe864bbca47daa45c4f63537fb49bf9438656c53e1253f17686d51b19f576cdabe6e695e1eb35a0b71f90cae9769d8c99db21450e78b773f1d28070df3f5266540bd0d5fec94415cdc6af562d190428f59a602c6fe928e25a5f068933af522d69f55979497d2cf5166aa6f68ea19679714ab25f1c9153ce7b465caf941f6ed8b28206e4b3f42d88bd7d4548d8a89da68c5bc76733006097961b22038351e5f6c0ae1e743048b8e0b27fe5f20b7049fa6a87a24435c005370c4fd0f45951ca8b129f7ca6bcede2a2ef50763caefb46f7a85a8341758f7b89b09d54527ac9d3ecc2557ce82a88ca5c762b1b5b2829d5e473704a01fef682e22e3aeed9e0d84a5f4e62e92881cc43f93bd18c4eb426d1d99be0989c8059a4a22991057903320bebbd038b4f5c9d316d8f678bc7ddc374a463a3a310477491806e7aeaaf6e1040a9f279bad4149ffa7e54c57d195891fd1b40031cdc11f562fe9597e34ef4c4c9c44ba69cc77e30beee8b4ce4f05a4ecda2bb4595e40ca4429c8f5aba6dcd5d6461db5978e6c8a406e2b65a0806450ebc6f946d36d35b57153d9cadf3e94d3d6471d048d6c8feeffa1d68f7cd7794a69c6c38cb0adaddddd14da3bf1067dce5e8ba82a4c981af6f315aa1ac3676e6c8a7644a6dbaa1b4f8df6b0a0d3beb3e55bf869b077266b3dd3d393786194cbeeae3d83a81ec54db8be484078aca3e274d55b1b7a4b4634d76578a82ebda887113708cc50343cefb7ecf4afd1e02b4b60fb4fe935d769a790008993ac97868b343c6ddb0064f0a2a96cc5be64eaa8a0d1a8d7eb0ed18703bc0786ae411bd29ac610d8a328e677235d7d6401107b1579dc6f4e8a7acc0ae011f74406f499327e3502b1e072cf843c9466c4500f79d1e57d83ff1dea4154b5d12300983c69c3991b7eb4cc21439861e307eeabc8e25764136fb85782bf5161e0ffaa1a0ac133bd4d514481324c328bfa31d0de9b41b6c496522de15e142c8628df0e9127dc1b6f465cbe14f8039f11a6bba42cd97f584d6523babd1a07bfb5275b1df647bd8f88e20344080ffcb30e65b61cad5fbcb6d89950f7858a948cbea91306055842da0c672992bfed6707b4b355527e0ca987522019eb030bf4f4039a4280725beab491e43bbfe70299ce382f7261e1bfb4d174ff0cacebdf613b6e3afaa26d6f8077d5bb3232eb9a831eb2fcafa03892f4495958313ab3470332bbfa20dd05bc19710167c594c66870e7e42dece793b9f84fce9731f142e9614dc81707d31b99255e17a78cc40c5b911f8563cf15218418ce77843f136ecd9584ed8e811d2ff53ed550385654aabef478bbe8827a45a7cc61c394cf33e37756b89f69188f673f54f7560e3bc316c0ab7a43ea139e2fe61a70febeb17eea37dbd4218833cd9c08e4a91bc66dd980a8ddc506943f952693d9ddf0d23197111a922c201e6cec921a50fe3a620fd4e5b53f277056095d19daf3d7f6975a2e86501baa3b5733e4b162433ec25b6d96cf4eb12d3bd1f105188ab8c041edeaa876b91354665c6144dbe66a67443c4199e2fb012ff24ca8f6d3d35f3f8cebcc46e4e889fb912fccf3d6a1138588b9e1720bdc9982befb169325368a353c7f204f791cfcbacf6418a8dddea5e62ddda4c9cd568db0978c4580a8ddafcf5594bbd8563eb9fb48b30c441b054c6c83f9453adfe0bdf68d0227e6ef3d455776ecd1c642536e55257965b06ef489f918513769e50f795b15</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
            <tag> 每日记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基本数据类型</title>
      <link href="/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h1 id="1-包装类型"><a href="#1-包装类型" class="headerlink" title="1. 包装类型"></a>1. 包装类型</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>Java 的包装类型（Wrapper Class）是对基本数据类型的对象表示，用于将基本数据类型（如 <code>int</code>、<code>double</code>）包装为类对象。包装类存在的主要目的是使基本数据类型能够与 Java 的集合框架（如 <code>ArrayList</code>）等只能操作对象的API兼容。</p><h2 id="1-2-基本类型和包装类型的区别"><a href="#1-2-基本类型和包装类型的区别" class="headerlink" title="1.2 基本类型和包装类型的区别"></a>1.2 基本类型和包装类型的区别</h2><ul><li>用途：定义一些常用变量或局部变量会使用基本类型；在对象属性，方法参数中会使用包装类型，同时包装类型可用于泛型。</li><li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，存储在堆中。</li><li>占用空间：基本数据类型占用空间小。</li><li>默认值：成员变量包装类不赋值就是null，基本数据类型有默认值。</li><li>比较方式：基本数据类型中，&#x3D;&#x3D;比较的是数值是否相同；对于包装类型来说，&#x3D;&#x3D;比较的是对象的内存地址，equals可以比较数值大小。</li></ul><h2 id="1-3-包装类型的缓存机制"><a href="#1-3-包装类型的缓存机制" class="headerlink" title="1.3 包装类型的缓存机制"></a>1.3 包装类型的缓存机制</h2><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><h2 id="1-4-自动装箱与拆箱"><a href="#1-4-自动装箱与拆箱" class="headerlink" title="1.4 自动装箱与拆箱"></a>1.4 自动装箱与拆箱</h2><h3 id="1-4-1-定义"><a href="#1-4-1-定义" class="headerlink" title="1.4.1 定义"></a>1.4.1 定义</h3><p>自动装箱：将基本数据类型转换为对应的包装类对象。</p><p>自动拆箱：将包装类对象自动转换为对应的基本数据类型。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2-综合理解装箱和包装类缓存机制"><a href="#1-4-2-综合理解装箱和包装类缓存机制" class="headerlink" title="1.4.2 综合理解装箱和包装类缓存机制"></a>1.4.2 综合理解装箱和包装类缓存机制</h3><p>下面我们来看一个问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。</p><p>下面是另一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">// true, 因为值在缓存范围内（-128 到 127）</span></span><br><span class="line">System.out.println(a.equals(b));  <span class="comment">// true, 比较值</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);  <span class="comment">// false, 超出缓存范围</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-BigDecimal"><a href="#2-BigDecimal" class="headerlink" title="2. BigDecimal"></a>2. BigDecimal</h1><h2 id="2-1-为什么浮点数运算的时候会有精度丢失的风险"><a href="#2-1-为什么浮点数运算的时候会有精度丢失的风险" class="headerlink" title="2.1 为什么浮点数运算的时候会有精度丢失的风险"></a>2.1 为什么浮点数运算的时候会有精度丢失的风险</h2><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h2 id="2-2-如何解决这个问题"><a href="#2-2-如何解决这个问题" class="headerlink" title="2.2 如何解决这个问题"></a>2.2 如何解决这个问题</h2><p>使用BigDecimal，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(c);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.2 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.20 */</span></span><br><span class="line"><span class="comment">// 比较内容，不是比较值</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* false */</span></span><br><span class="line"><span class="comment">// 比较值相等用相等compareTo，相等返回0</span></span><br><span class="line">System.out.println(<span class="number">0</span> == x.compareTo(y)); <span class="comment">/* true */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BigDecimal 是以字符串或整数形式存储的，所有运算都遵循十进制规则。</p><h1 id="3-超过long整型数据应该如何表示"><a href="#3-超过long整型数据应该如何表示" class="headerlink" title="3. 超过long整型数据应该如何表示"></a>3. 超过long整型数据应该如何表示</h1><p>使用BigInteger，<code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java自定义注解</title>
      <link href="/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="公共字段填充"><a href="#公共字段填充" class="headerlink" title="公共字段填充"></a>公共字段填充</h1><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p>我们在update和insert操作时需要修改创建时间，修改时间，修改人id，且这几种属性都属于公共属性，即所有的表都含有这个属性，如果通过service操作会显得非常繁琐，所以我们使用自定义注解的方式完成。</p><h1 id="2-自定义注解AtuoFill"><a href="#2-自定义注解AtuoFill" class="headerlink" title="2. 自定义注解AtuoFill"></a>2. 自定义注解AtuoFill</h1><p>自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法。自定义注解前要写上两个注解：</p><ul><li>一个是@Target(ElementType.METHOD)，这个注解用来指定当前注解只能加在方法上。</li><li>另一个注解是@Retention(RetentionPolicy.RUNTIME)，这个注解用来指定当前注解在什么阶段被保留，这里表示注解在运行时会被 JVM 保留</li></ul><p>这里的value是注解的一个属性，它的作用是接收一个 OperationType 类型的值，该值用来表示操作的类型（例如 INSERT 或 UPDATE）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>     <span class="comment">//指定当前注解只能加在方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>     <span class="comment">//指定当前注解的生命周期，这里表示注解在运行时会被 JVM 保留</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    <span class="comment">//指定数据库操作类型: UPDATE, INSERT</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-定义切面类"><a href="#3-定义切面类" class="headerlink" title="3. 定义切面类"></a>3. 定义切面类</h1><p>因为要想实现自动填充方法，我们就需要在程序insert&#x2F;update前拦截这个mapper方法，并进行相关操作，这时就用到了切面编程的相关思想。</p><h2 id="3-1-切面类"><a href="#3-1-切面类" class="headerlink" title="3.1 切面类"></a>3.1 切面类</h2><p>声明一个类为切面类，切面类可以包含：</p><ul><li><strong>通知（Advice）</strong>：在程序执行的特定点（切点）上执行的代码。</li><li><strong>切点（Pointcut）</strong>：定义在哪些连接点上执行通知。</li><li><strong>引入（Introduction）</strong>：向目标类添加新的方法或属性。</li></ul><p>简单来说，切点的目的是告诉这个切面类哪些方法可以拦截；通知是拦截前&#x2F;后需要执行的操作，所以又可以分为前置通知，后置通知，返回通知，。</p><ul><li><strong>前置通知@Before</strong>：在目标方法执行之前执行的通知。用于在方法执行前进行准备工作，如参数校验、权限检查等。</li><li><strong>后置通知@After</strong>：在目标方法执行之后执行的通知，不管目标方法是否抛出异常。用于执行清理操作，如释放资源等。</li><li><strong>返回通知@AfterReturning</strong>：在目标方法正常执行完毕后执行的通知，且能够访问目标方法的返回值。用于在方法执行完后对返回结果进行处理，如日志记录、返回值的修改等。</li><li><strong>异常通知@AfterThrowing</strong>：当目标方法抛出异常时执行的通知。用于处理异常，比如日志记录、异常处理等。</li><li><strong>环绕通知（@Around）</strong>：包围目标方法执行的通知，可以控制目标方法的执行，甚至可以选择不执行目标方法。用于在方法执行前后加入自定义逻辑，例如：事务管理、性能统计等。它是最强大的通知类型，可以访问方法的参数、返回值，还可以控制目标方法是否执行。</li></ul><h2 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h2><h3 id="3-2-1-获取数据库操作类型"><a href="#3-2-1-获取数据库操作类型" class="headerlink" title="3.2.1 获取数据库操作类型"></a>3.2.1 获取数据库操作类型</h3><p>首先需要获得当前被拦截方法的数据库操作类型insert&#x2F;update，这里使用了反射的知识，joinPoint参数是被拦截的方法的信息，通过使用joinPoint，我们可以获得被拦截的方法的具体参数等信息。</p><p>我们使用joinPoint.getSignature()获得方法签名对象，但是signature是父类，其中没有获得方法参数的具体实现，所以我们要将他转化为子类MethodSignature，子类重写了父类方法，可以获得被拦截的方法信息。</p><p>再通过getAnnotation可以获得注解对象，同时调用注解对象的value属性就可以获得操作类型是insert还是update了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// joinPoint为拦截时传入的参数</span></span><br><span class="line">        log.info(<span class="string">&quot;开始进行公共字段的自动填充...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前被拦截方法的数据库操作类型</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();     <span class="comment">//方法签名对象</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);        <span class="comment">//获得方法上的注解对象</span></span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value();     <span class="comment">//获得数据库操作类型</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-获取当前被拦截的方法参数（实体对象）"><a href="#3-2-2-获取当前被拦截的方法参数（实体对象）" class="headerlink" title="3.2.2 获取当前被拦截的方法参数（实体对象）"></a>3.2.2 获取当前被拦截的方法参数（实体对象）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前被拦截的方法参数（实体对象）</span></span><br><span class="line">Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="keyword">if</span>(args == <span class="literal">null</span> || args.length == <span class="number">0</span>) &#123;      <span class="comment">//如果没有参数，返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>];    <span class="comment">//得到第一个参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-3-准备数据"><a href="#3-2-3-准备数据" class="headerlink" title="3.2.3 准备数据"></a>3.2.3 准备数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备赋值的数据</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-4-赋值"><a href="#3-2-4-赋值" class="headerlink" title="3.2.4 赋值"></a>3.2.4 赋值</h3><p>先使用entity反射获得方法，再通过invoke去使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据当前不同操作类型，为对应的属性通过反射来赋值</span></span><br><span class="line">        <span class="keyword">if</span>(operationType == OperationType.INSERT) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setCreateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setCreateUser&quot;</span>, Long.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, Long.class);</span><br><span class="line"></span><br><span class="line">                setCreateTime.invoke(entity, localDateTime);</span><br><span class="line">                setUpdateTime.invoke(entity, localDateTime);</span><br><span class="line">                setCreateUser.invoke(entity, currentId);</span><br><span class="line">                setUpdateUser.invoke(entity, currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operationType == OperationType.UPDATE) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Method setCreateTime = entity.getClass().getDeclaredMethod(&quot;setCreateTime&quot;, LocalDateTime.class);</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="comment">//Method setCreateUser = entity.getClass().getDeclaredMethod(&quot;setCreateUser&quot;, Long.class);</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//setCreateTime.invoke(entity, localDateTime);</span></span><br><span class="line">                setUpdateTime.invoke(entity, localDateTime);</span><br><span class="line">                <span class="comment">//setCreateUser.invoke(entity, currentId);</span></span><br><span class="line">                setUpdateUser.invoke(entity, currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> 苍穹项目笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础概念与常识</title>
      <link href="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/"/>
      <url>/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h1><h1 id="1-JVM与JDK与JRE"><a href="#1-JVM与JDK与JRE" class="headerlink" title="1. JVM与JDK与JRE"></a>1. JVM与JDK与JRE</h1><h2 id="1-1-JVM"><a href="#1-1-JVM" class="headerlink" title="1.1 JVM"></a>1.1 JVM</h2><p>JVM是java虚拟机，是运行java字节码的虚拟机。JVM会针对不同的操作系统开发不同版本的JVM，目的是在不同操作系统上运行相同的字节码都会给出相同的结果。</p><p>同时，不同的编程语言都可以生成字节码，并运行在jvm上</p><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_I2PrrZf6yR.png"></p><h2 id="1-2-JDK"><a href="#1-2-JDK" class="headerlink" title="1.2 JDK"></a>1.2 JDK</h2><p>jdk全称为Java Development Kit，是java开发工具包。它包含了：JRE（java runtime environment），编译器javac和其他工具。</p><h2 id="1-3-JRE"><a href="#1-3-JRE" class="headerlink" title="1.3 JRE"></a>1.3 JRE</h2><p>jre是java运行已编译java程序的环境，主要包括：JVM，java基础类库。</p><h2 id="1-4-JDK和JRE的关系"><a href="#1-4-JDK和JRE的关系" class="headerlink" title="1.4 JDK和JRE的关系"></a>1.4 JDK和JRE的关系</h2><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_nYdCCkPCQa.png"></p><h1 id="2-字节码"><a href="#2-字节码" class="headerlink" title="2. 字节码"></a>2. 字节码</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>字节码就是java程序编译后生成的.class文件。字节码只面向JVM虚拟机。</p><h2 id="2-2-好处"><a href="#2-2-好处" class="headerlink" title="2.2 好处"></a>2.2 好处</h2><p>字节码只面向JVM虚拟机，不面向任何特定处理器。这样会在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><h2 id="2-3-java程序运行过程-x20"><a href="#2-3-java程序运行过程-x20" class="headerlink" title="2.3 java程序运行过程&#x20;"></a>2.3 java程序运行过程&#x20;</h2><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_l-yZMFDxNr.png"></p><h2 id="2-4-解释器与JIT"><a href="#2-4-解释器与JIT" class="headerlink" title="2.4 解释器与JIT"></a>2.4 解释器与JIT</h2><p>在.class文件到机器码这一步中，JVM首先加载字节码的文件，然后通过解释器逐行解释代码，这种逐行解释的方式较慢，所以引入了JIT（just in time）编译器，JIT属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>这里补充一下解释器和编译器的区别：</p><ul><li>编译器将字节码<strong>一次性翻译成完整的机器码</strong>。</li><li>解释器逐条将字节码翻译为机器码，再执行。</li></ul><p>从.class → 机器码这一过程可以看出，java既使用了编译器，又使用了解释器，所以java是编译与解释共存的语言。</p><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_1SrpaNkuzr.png"></p><h1 id="3-AOT"><a href="#3-AOT" class="headerlink" title="3. AOT"></a>3. AOT</h1><h2 id="3-1-AOT是什么"><a href="#3-1-AOT是什么" class="headerlink" title="3.1 AOT是什么"></a>3.1 AOT是什么</h2><p>AOT全称为ahead of time compilation，意思是在程序被执行前就将其编译成机器码，属于静态编译（类似于C++）</p><h2 id="3-2-AOT优点"><a href="#3-2-AOT优点" class="headerlink" title="3.2 AOT优点"></a>3.2 AOT优点</h2><p>AOT 的主要优势在于启动时间、内存占用和打包体积。</p><ul><li>AOT避免了JIT预热的开销，提高了java的启动速度。</li><li>减少内存占用：JIT和解释器都需要用字节码，而AOT模式在程序部署前就已经编译为本地机器码，不需要解释器和JIT编译器。</li><li>增强程序安全性：很难反编译。</li></ul><h2 id="3-3-AOT与JIT"><a href="#3-3-AOT与JIT" class="headerlink" title="3.3 AOT与JIT"></a>3.3 AOT与JIT</h2><p>AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理。而很多框架都要用到这些动态特性，如spring。</p><p>JIT具备更高的极限处理能力（JIT可以记录很多热点代码）</p><h1 id="4-java和C-区别"><a href="#4-java和C-区别" class="headerlink" title="4. java和C++区别"></a>4. java和C++区别</h1><ul><li>java中不提供指针访问内存，线程更加安全</li><li>java的类是单继承，C++的类可以多继承。但是java的接口可以多继承</li><li>java可以自动回收内存</li><li>C++支持方法重载和运算符重载，java只支持方法重载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
