<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Icyyybro</title>
  
  <subtitle>欢迎来到Yichuan Wang的世界</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-07T14:59:33.047Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>YiChuan Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024年12月7日</title>
    <link href="http://example.com/2024/12/07/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024%E5%B9%B412%E6%9C%887%E6%97%A5/"/>
    <id>http://example.com/2024/12/07/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024%E5%B9%B412%E6%9C%887%E6%97%A5/</id>
    <published>2024-12-07T06:23:52.000Z</published>
    <updated>2024-12-07T14:59:33.047Z</updated>
    
    <content type="html"><![CDATA[<p>昨天晚上和父母通话，我想了很多问题，打算随手记录一下。</p><h1 id="1-摇摆不定"><a href="#1-摇摆不定" class="headerlink" title="1 摇摆不定"></a>1 摇摆不定</h1><p>​我是一个易受环境影响的人，我总是很关注别人的想法和做法，当别人的想法和我的想法冲突时候，我就会怀疑自己。就比如说，我听学长说做开发会比较稳定，职业发展不错的时候，我就想去做开发。然后我又听说某某做算法薪资很高，算法天花板比开发高，我可能又会放下手中的任务，去思考是否要转行做算法。</p><p>​但其实，我们大多数人是没法预知未来的，我们不知道算法是否会持续火热下去，不知道开发会不会被取代。既然这些都是无法预知，改变不了的，我们不如放下心来，从容一点，尽量减少关注那些带给我们焦虑的事务，多去做一些实际的事情，例如多学一些知识，多读读书，多思考思考自己想要什么。也不要关注别人取得了什么成就，别人选择了什么。坚定的走自己的道路，过自己想过的人生。</p><h1 id="2-焦虑"><a href="#2-焦虑" class="headerlink" title="2 焦虑"></a>2 焦虑</h1><p>​自从毕设开题后我就非常焦虑，一方面担心自己毕设做不出来，一方面抵触做毕设。直到现在还会时不时的焦虑。</p><p>​其实仔细想想，大学四年这一路走来自己一直都在焦虑。在大一读材料时，觉得自己的专业没有未来，整天焦虑自己能不能转专业。等到自己真的转专业成功了，又在焦虑自己能不能补休完课程，能不能保研。等到保研完了，又焦虑自己能不能毕业，能不能找到好工作。。。我一直都在焦虑，但是，仔细想想，这些我焦虑，担心的事情，绝大多数并不会发生，我顺利转专业了，顺利保研了，甚至保研的院校比我大一时想的要好，这些焦虑是过分多余的，除了浪费时间一点作用也没有。</p><p>​在仔细深究一下自己为什么会焦虑，我觉得主要有三点原因。首先是我太爱和别人比较了，我总是担心自己不够好，每当别人做的比我好，学的比我多，我就会焦虑。就说这次保研，我的焦虑其实并不来源于我的学校层次不好，而是来源于我和他人比较，觉得我没有别人的好。其次，我害怕失败，哪怕是一点点失误我都很害怕，我想做到完美。最后，就是我太受别人的言论影响了，别人说这个不行，我就觉得这个不行。</p><p>​要真正的摆脱焦虑，我觉得首先需要接纳自己，我并不是万能的，在每个领域都有强者，不要想着做到最好，适度的降低预期，这样总会产生超出预期的结果，也会给我正向反馈，使我更加自信。其次，抱着一颗从容的心，既然焦虑不能让你的毕设快速做完，那就每天做一点，一步一步慢慢的完成。每当完成一点，就会多一份信心。</p><h1 id="3-期望"><a href="#3-期望" class="headerlink" title="3 期望"></a>3 期望</h1><p>​衷心的期望自己能拜托焦虑，坚定自己的道路，迎接更好的自己。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天晚上和父母通话，我想了很多问题，打算随手记录一下。&lt;/p&gt;
&lt;h1 id=&quot;1-摇摆不定&quot;&gt;&lt;a href=&quot;#1-摇摆不定&quot; class=&quot;headerlink&quot; title=&quot;1 摇摆不定&quot;&gt;&lt;/a&gt;1 摇摆不定&lt;/h1&gt;&lt;p&gt;​	我是一个易受环境影响的人，我总是很</summary>
      
    
    
    
    
    <category term="生活随笔" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="感悟" scheme="http://example.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象基础</title>
    <link href="http://example.com/2024/12/05/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/12/05/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2024-12-05T14:25:28.000Z</published>
    <updated>2024-12-05T14:36:23.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h1 id="1-面向对象和面向过程"><a href="#1-面向对象和面向过程" class="headerlink" title="1. 面向对象和面向过程"></a>1. 面向对象和面向过程</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><ul><li><strong>面向过程编程（POP）</strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li><strong>面向对象编程（OOP）</strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><h2 id="1-2-面向对象优点"><a href="#1-2-面向对象优点" class="headerlink" title="1.2 面向对象优点"></a>1.2 面向对象优点</h2><ul><li><strong>易维护</strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。</li><li><strong>易复用</strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。</li><li><strong>易扩展</strong>：模块化设计使得系统扩展变得更加容易和灵活。</li></ul><h1 id="2-面向对象三大特征"><a href="#2-面向对象三大特征" class="headerlink" title="2. 面向对象三大特征"></a>2. 面向对象三大特征</h1><h2 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h2><p>将对象的属性隐藏在对象内部，不允许外部对象直接访问对象内部的信息，但可以通过这个对象提供的方法操作属性。</p><h2 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h2><p>继承是在已存在的类的定义作为基础创建新类，新类可以增加新的数据和功能，也可以使用父类功能。</p><p>注意：</p><ul><li>子类拥有父类所有属性和方法（包括私有属性和方法），但是不能访问父类的私有属性和方法。</li></ul><h2 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h2><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>多态特点：</p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定</li><li>多态不能调用“只在子类存在但在父类不存在”的方法</li><li>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法</li></ul><h1 id="3-接口和抽象类"><a href="#3-接口和抽象类" class="headerlink" title="3. 接口和抽象类"></a>3. 接口和抽象类</h1><h2 id="3-1-共同点"><a href="#3-1-共同点" class="headerlink" title="3.1 共同点"></a>3.1 共同点</h2><ul><li>实例化：接口和抽象类都不能直接实例化，只能被实现或继承后才能创建具体的对象。</li><li>抽象方法：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</li></ul><h2 id="3-2-不同点"><a href="#3-2-不同点" class="headerlink" title="3.2 不同点"></a>3.2 不同点</h2><ul><li>设计目的：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>继承和实现：类只能单继承，接口可以多继承。同时一个类可以实现多个接口。</li><li>成员变量：接口中的成员变量只能是public static final类型，不能被修改且必须有初始值。抽象类就没有这个限制。</li><li>方法：JAVA8之前，接口的方法只能是方法声明。JAVA8起，可以在接口中定义default方法和static方法。JAVA9起，接口可以包含private方法。</li></ul><h1 id="4-深拷贝，浅拷贝，引用拷贝"><a href="#4-深拷贝，浅拷贝，引用拷贝" class="headerlink" title="4. 深拷贝，浅拷贝，引用拷贝"></a>4. 深拷贝，浅拷贝，引用拷贝</h1><h2 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h2><ul><li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li>引用拷贝：新开一个引用指向需要拷贝的对象。</li></ul><p>拷贝实现可以实现Cloneable接口中的clone方法。</p><h2 id="4-2-比较"><a href="#4-2-比较" class="headerlink" title="4.2 比较"></a>4.2 比较</h2><p><img src="/2024/12/05/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/image_PyFqFWSnD2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象基础&quot;&gt;&lt;a href=&quot;#面向对象基础&quot; class=&quot;headerlink&quot; title=&quot;面向对象基础&quot;&gt;&lt;/a&gt;面向对象基础&lt;/h1&gt;&lt;h1 id=&quot;1-面向对象和面向过程&quot;&gt;&lt;a href=&quot;#1-面向对象和面向过程&quot; class=&quot;header</summary>
      
    
    
    
    <category term="后端开发" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java基础" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="面向对象" scheme="http://example.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>2024年12月3日</title>
    <link href="http://example.com/2024/12/03/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024-12-03/"/>
    <id>http://example.com/2024/12/03/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024-12-03/</id>
    <published>2024-12-03T14:22:10.000Z</published>
    <updated>2024-12-03T14:25:51.106Z</updated>
    
    <content type="html"><![CDATA[<p>今天上午去健身房锻炼了一上午，推肩时候没有拿稳哑铃，导致指甲给砸肿了。不过令我烦躁的不在这，而是健身太浪费时间了，一上午的时间全浪费在健身了，以后得早起先去实验室学一会了。</p><p>下午2：00开始学习，今天学了苍穹外卖项目中的自定义注解，同时涉及到反射等知识，收获颇多，晚上刷了几道leetcode就开始背java八股了。</p><p>这几天总是在纠结未来的就业方向，到底是做搜广推还是java后端开发。这两个我都不排斥，想做搜广推的原因是薪资高，但是我怕我实习不够，又没有论文，这样竞争力会小很多；开发则相对稳定，但是薪资会比开发少。还有最主要的一个问题是氛围问题，研究生实验室的学长学姐都是做的开发，如果一个人做算法感觉没有人指导，没有氛围。其实我感觉无论我选择什么方向，我未来都会后悔的，因为人总是会美化自己从没有走过的道路。</p><p>我这几天还在担心我的毕设问题，一直想赶快解决，但是又无从下手，没有创新点，而且仿真平台一直报错，我打算这几天找一篇用开环数据集做的模型复现一下，然后自己想一个创新点加进去，完成这个毕设，然后下学期一定一定要找实习了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天上午去健身房锻炼了一上午，推肩时候没有拿稳哑铃，导致指甲给砸肿了。不过令我烦躁的不在这，而是健身太浪费时间了，一上午的时间全浪费在健身了，以后得早起先去实验室学一会了。&lt;/p&gt;
&lt;p&gt;下午2：00开始学习，今天学了苍穹外卖项目中的自定义注解，同时涉及到反射等知识，收获颇</summary>
      
    
    
    
    <category term="生活随笔" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="生活随笔" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    <category term="每日记录" scheme="http://example.com/tags/%E6%AF%8F%E6%97%A5%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>java基本数据类型</title>
    <link href="http://example.com/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-12-03T11:35:55.000Z</published>
    <updated>2024-12-03T11:38:20.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h1 id="1-包装类型"><a href="#1-包装类型" class="headerlink" title="1. 包装类型"></a>1. 包装类型</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>Java 的包装类型（Wrapper Class）是对基本数据类型的对象表示，用于将基本数据类型（如 <code>int</code>、<code>double</code>）包装为类对象。包装类存在的主要目的是使基本数据类型能够与 Java 的集合框架（如 <code>ArrayList</code>）等只能操作对象的API兼容。</p><h2 id="1-2-基本类型和包装类型的区别"><a href="#1-2-基本类型和包装类型的区别" class="headerlink" title="1.2 基本类型和包装类型的区别"></a>1.2 基本类型和包装类型的区别</h2><ul><li>用途：定义一些常用变量或局部变量会使用基本类型；在对象属性，方法参数中会使用包装类型，同时包装类型可用于泛型。</li><li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，存储在堆中。</li><li>占用空间：基本数据类型占用空间小。</li><li>默认值：成员变量包装类不赋值就是null，基本数据类型有默认值。</li><li>比较方式：基本数据类型中，&#x3D;&#x3D;比较的是数值是否相同；对于包装类型来说，&#x3D;&#x3D;比较的是对象的内存地址，equals可以比较数值大小。</li></ul><h2 id="1-3-包装类型的缓存机制"><a href="#1-3-包装类型的缓存机制" class="headerlink" title="1.3 包装类型的缓存机制"></a>1.3 包装类型的缓存机制</h2><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><h2 id="1-4-自动装箱与拆箱"><a href="#1-4-自动装箱与拆箱" class="headerlink" title="1.4 自动装箱与拆箱"></a>1.4 自动装箱与拆箱</h2><h3 id="1-4-1-定义"><a href="#1-4-1-定义" class="headerlink" title="1.4.1 定义"></a>1.4.1 定义</h3><p>自动装箱：将基本数据类型转换为对应的包装类对象。</p><p>自动拆箱：将包装类对象自动转换为对应的基本数据类型。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2-综合理解装箱和包装类缓存机制"><a href="#1-4-2-综合理解装箱和包装类缓存机制" class="headerlink" title="1.4.2 综合理解装箱和包装类缓存机制"></a>1.4.2 综合理解装箱和包装类缓存机制</h3><p>下面我们来看一个问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。</p><p>下面是另一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">// true, 因为值在缓存范围内（-128 到 127）</span></span><br><span class="line">System.out.println(a.equals(b));  <span class="comment">// true, 比较值</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);  <span class="comment">// false, 超出缓存范围</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-BigDecimal"><a href="#2-BigDecimal" class="headerlink" title="2. BigDecimal"></a>2. BigDecimal</h1><h2 id="2-1-为什么浮点数运算的时候会有精度丢失的风险"><a href="#2-1-为什么浮点数运算的时候会有精度丢失的风险" class="headerlink" title="2.1 为什么浮点数运算的时候会有精度丢失的风险"></a>2.1 为什么浮点数运算的时候会有精度丢失的风险</h2><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h2 id="2-2-如何解决这个问题"><a href="#2-2-如何解决这个问题" class="headerlink" title="2.2 如何解决这个问题"></a>2.2 如何解决这个问题</h2><p>使用BigDecimal，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(c);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.2 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.20 */</span></span><br><span class="line"><span class="comment">// 比较内容，不是比较值</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* false */</span></span><br><span class="line"><span class="comment">// 比较值相等用相等compareTo，相等返回0</span></span><br><span class="line">System.out.println(<span class="number">0</span> == x.compareTo(y)); <span class="comment">/* true */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BigDecimal 是以字符串或整数形式存储的，所有运算都遵循十进制规则。</p><h1 id="3-超过long整型数据应该如何表示"><a href="#3-超过long整型数据应该如何表示" class="headerlink" title="3. 超过long整型数据应该如何表示"></a>3. 超过long整型数据应该如何表示</h1><p>使用BigInteger，<code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h1&gt;&lt;h1 id=&quot;1-包装类型&quot;&gt;&lt;a href=&quot;#1-包装类型&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="后端开发" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java基础" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java自定义注解</title>
    <link href="http://example.com/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <id>http://example.com/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</id>
    <published>2024-12-03T11:26:20.000Z</published>
    <updated>2024-12-03T11:38:06.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公共字段填充"><a href="#公共字段填充" class="headerlink" title="公共字段填充"></a>公共字段填充</h1><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p>我们在update和insert操作时需要修改创建时间，修改时间，修改人id，且这几种属性都属于公共属性，即所有的表都含有这个属性，如果通过service操作会显得非常繁琐，所以我们使用自定义注解的方式完成。</p><h1 id="2-自定义注解AtuoFill"><a href="#2-自定义注解AtuoFill" class="headerlink" title="2. 自定义注解AtuoFill"></a>2. 自定义注解AtuoFill</h1><p>自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法。自定义注解前要写上两个注解：</p><ul><li>一个是@Target(ElementType.METHOD)，这个注解用来指定当前注解只能加在方法上。</li><li>另一个注解是@Retention(RetentionPolicy.RUNTIME)，这个注解用来指定当前注解在什么阶段被保留，这里表示注解在运行时会被 JVM 保留</li></ul><p>这里的value是注解的一个属性，它的作用是接收一个 OperationType 类型的值，该值用来表示操作的类型（例如 INSERT 或 UPDATE）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>     <span class="comment">//指定当前注解只能加在方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>     <span class="comment">//指定当前注解的生命周期，这里表示注解在运行时会被 JVM 保留</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    <span class="comment">//指定数据库操作类型: UPDATE, INSERT</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-定义切面类"><a href="#3-定义切面类" class="headerlink" title="3. 定义切面类"></a>3. 定义切面类</h1><p>因为要想实现自动填充方法，我们就需要在程序insert&#x2F;update前拦截这个mapper方法，并进行相关操作，这时就用到了切面编程的相关思想。</p><h2 id="3-1-切面类"><a href="#3-1-切面类" class="headerlink" title="3.1 切面类"></a>3.1 切面类</h2><p>声明一个类为切面类，切面类可以包含：</p><ul><li><strong>通知（Advice）</strong>：在程序执行的特定点（切点）上执行的代码。</li><li><strong>切点（Pointcut）</strong>：定义在哪些连接点上执行通知。</li><li><strong>引入（Introduction）</strong>：向目标类添加新的方法或属性。</li></ul><p>简单来说，切点的目的是告诉这个切面类哪些方法可以拦截；通知是拦截前&#x2F;后需要执行的操作，所以又可以分为前置通知，后置通知，返回通知，。</p><ul><li><strong>前置通知@Before</strong>：在目标方法执行之前执行的通知。用于在方法执行前进行准备工作，如参数校验、权限检查等。</li><li><strong>后置通知@After</strong>：在目标方法执行之后执行的通知，不管目标方法是否抛出异常。用于执行清理操作，如释放资源等。</li><li><strong>返回通知@AfterReturning</strong>：在目标方法正常执行完毕后执行的通知，且能够访问目标方法的返回值。用于在方法执行完后对返回结果进行处理，如日志记录、返回值的修改等。</li><li><strong>异常通知@AfterThrowing</strong>：当目标方法抛出异常时执行的通知。用于处理异常，比如日志记录、异常处理等。</li><li><strong>环绕通知（@Around）</strong>：包围目标方法执行的通知，可以控制目标方法的执行，甚至可以选择不执行目标方法。用于在方法执行前后加入自定义逻辑，例如：事务管理、性能统计等。它是最强大的通知类型，可以访问方法的参数、返回值，还可以控制目标方法是否执行。</li></ul><h2 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h2><h3 id="3-2-1-获取数据库操作类型"><a href="#3-2-1-获取数据库操作类型" class="headerlink" title="3.2.1 获取数据库操作类型"></a>3.2.1 获取数据库操作类型</h3><p>首先需要获得当前被拦截方法的数据库操作类型insert&#x2F;update，这里使用了反射的知识，joinPoint参数是被拦截的方法的信息，通过使用joinPoint，我们可以获得被拦截的方法的具体参数等信息。</p><p>我们使用joinPoint.getSignature()获得方法签名对象，但是signature是父类，其中没有获得方法参数的具体实现，所以我们要将他转化为子类MethodSignature，子类重写了父类方法，可以获得被拦截的方法信息。</p><p>再通过getAnnotation可以获得注解对象，同时调用注解对象的value属性就可以获得操作类型是insert还是update了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// joinPoint为拦截时传入的参数</span></span><br><span class="line">        log.info(<span class="string">&quot;开始进行公共字段的自动填充...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前被拦截方法的数据库操作类型</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();     <span class="comment">//方法签名对象</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);        <span class="comment">//获得方法上的注解对象</span></span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value();     <span class="comment">//获得数据库操作类型</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-获取当前被拦截的方法参数（实体对象）"><a href="#3-2-2-获取当前被拦截的方法参数（实体对象）" class="headerlink" title="3.2.2 获取当前被拦截的方法参数（实体对象）"></a>3.2.2 获取当前被拦截的方法参数（实体对象）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前被拦截的方法参数（实体对象）</span></span><br><span class="line">Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="keyword">if</span>(args == <span class="literal">null</span> || args.length == <span class="number">0</span>) &#123;      <span class="comment">//如果没有参数，返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>];    <span class="comment">//得到第一个参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-3-准备数据"><a href="#3-2-3-准备数据" class="headerlink" title="3.2.3 准备数据"></a>3.2.3 准备数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备赋值的数据</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-4-赋值"><a href="#3-2-4-赋值" class="headerlink" title="3.2.4 赋值"></a>3.2.4 赋值</h3><p>先使用entity反射获得方法，再通过invoke去使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据当前不同操作类型，为对应的属性通过反射来赋值</span></span><br><span class="line">        <span class="keyword">if</span>(operationType == OperationType.INSERT) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setCreateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setCreateUser&quot;</span>, Long.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, Long.class);</span><br><span class="line"></span><br><span class="line">                setCreateTime.invoke(entity, localDateTime);</span><br><span class="line">                setUpdateTime.invoke(entity, localDateTime);</span><br><span class="line">                setCreateUser.invoke(entity, currentId);</span><br><span class="line">                setUpdateUser.invoke(entity, currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operationType == OperationType.UPDATE) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Method setCreateTime = entity.getClass().getDeclaredMethod(&quot;setCreateTime&quot;, LocalDateTime.class);</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="comment">//Method setCreateUser = entity.getClass().getDeclaredMethod(&quot;setCreateUser&quot;, Long.class);</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//setCreateTime.invoke(entity, localDateTime);</span></span><br><span class="line">                setUpdateTime.invoke(entity, localDateTime);</span><br><span class="line">                <span class="comment">//setCreateUser.invoke(entity, currentId);</span></span><br><span class="line">                setUpdateUser.invoke(entity, currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公共字段填充&quot;&gt;&lt;a href=&quot;#公共字段填充&quot; class=&quot;headerlink&quot; title=&quot;公共字段填充&quot;&gt;&lt;/a&gt;公共字段填充&lt;/h1&gt;&lt;h1 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="后端开发" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="苍穹项目笔记" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%8B%8D%E7%A9%B9%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础概念与常识</title>
    <link href="http://example.com/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/"/>
    <id>http://example.com/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/</id>
    <published>2024-12-02T11:17:32.000Z</published>
    <updated>2024-12-03T11:33:03.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h1><h1 id="1-JVM与JDK与JRE"><a href="#1-JVM与JDK与JRE" class="headerlink" title="1. JVM与JDK与JRE"></a>1. JVM与JDK与JRE</h1><h2 id="1-1-JVM"><a href="#1-1-JVM" class="headerlink" title="1.1 JVM"></a>1.1 JVM</h2><p>JVM是java虚拟机，是运行java字节码的虚拟机。JVM会针对不同的操作系统开发不同版本的JVM，目的是在不同操作系统上运行相同的字节码都会给出相同的结果。</p><p>同时，不同的编程语言都可以生成字节码，并运行在jvm上</p><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_I2PrrZf6yR.png"></p><h2 id="1-2-JDK"><a href="#1-2-JDK" class="headerlink" title="1.2 JDK"></a>1.2 JDK</h2><p>jdk全称为Java Development Kit，是java开发工具包。它包含了：JRE（java runtime environment），编译器javac和其他工具。</p><h2 id="1-3-JRE"><a href="#1-3-JRE" class="headerlink" title="1.3 JRE"></a>1.3 JRE</h2><p>jre是java运行已编译java程序的环境，主要包括：JVM，java基础类库。</p><h2 id="1-4-JDK和JRE的关系"><a href="#1-4-JDK和JRE的关系" class="headerlink" title="1.4 JDK和JRE的关系"></a>1.4 JDK和JRE的关系</h2><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_nYdCCkPCQa.png"></p><h1 id="2-字节码"><a href="#2-字节码" class="headerlink" title="2. 字节码"></a>2. 字节码</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>字节码就是java程序编译后生成的.class文件。字节码只面向JVM虚拟机。</p><h2 id="2-2-好处"><a href="#2-2-好处" class="headerlink" title="2.2 好处"></a>2.2 好处</h2><p>字节码只面向JVM虚拟机，不面向任何特定处理器。这样会在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><h2 id="2-3-java程序运行过程-x20"><a href="#2-3-java程序运行过程-x20" class="headerlink" title="2.3 java程序运行过程&#x20;"></a>2.3 java程序运行过程&#x20;</h2><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_l-yZMFDxNr.png"></p><h2 id="2-4-解释器与JIT"><a href="#2-4-解释器与JIT" class="headerlink" title="2.4 解释器与JIT"></a>2.4 解释器与JIT</h2><p>在.class文件到机器码这一步中，JVM首先加载字节码的文件，然后通过解释器逐行解释代码，这种逐行解释的方式较慢，所以引入了JIT（just in time）编译器，JIT属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>这里补充一下解释器和编译器的区别：</p><ul><li>编译器将字节码<strong>一次性翻译成完整的机器码</strong>。</li><li>解释器逐条将字节码翻译为机器码，再执行。</li></ul><p>从.class → 机器码这一过程可以看出，java既使用了编译器，又使用了解释器，所以java是编译与解释共存的语言。</p><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_1SrpaNkuzr.png"></p><h1 id="3-AOT"><a href="#3-AOT" class="headerlink" title="3. AOT"></a>3. AOT</h1><h2 id="3-1-AOT是什么"><a href="#3-1-AOT是什么" class="headerlink" title="3.1 AOT是什么"></a>3.1 AOT是什么</h2><p>AOT全称为ahead of time compilation，意思是在程序被执行前就将其编译成机器码，属于静态编译（类似于C++）</p><h2 id="3-2-AOT优点"><a href="#3-2-AOT优点" class="headerlink" title="3.2 AOT优点"></a>3.2 AOT优点</h2><p>AOT 的主要优势在于启动时间、内存占用和打包体积。</p><ul><li>AOT避免了JIT预热的开销，提高了java的启动速度。</li><li>减少内存占用：JIT和解释器都需要用字节码，而AOT模式在程序部署前就已经编译为本地机器码，不需要解释器和JIT编译器。</li><li>增强程序安全性：很难反编译。</li></ul><h2 id="3-3-AOT与JIT"><a href="#3-3-AOT与JIT" class="headerlink" title="3.3 AOT与JIT"></a>3.3 AOT与JIT</h2><p>AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理。而很多框架都要用到这些动态特性，如spring。</p><p>JIT具备更高的极限处理能力（JIT可以记录很多热点代码）</p><h1 id="4-java和C-区别"><a href="#4-java和C-区别" class="headerlink" title="4. java和C++区别"></a>4. java和C++区别</h1><ul><li>java中不提供指针访问内存，线程更加安全</li><li>java的类是单继承，C++的类可以多继承。但是java的接口可以多继承</li><li>java可以自动回收内存</li><li>C++支持方法重载和运算符重载，java只支持方法重载。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念与常识&quot;&gt;&lt;a href=&quot;#基础概念与常识&quot; class=&quot;headerlink&quot; title=&quot;基础概念与常识&quot;&gt;&lt;/a&gt;基础概念与常识&lt;/h1&gt;&lt;h1 id=&quot;1-JVM与JDK与JRE&quot;&gt;&lt;a href=&quot;#1-JVM与JDK与JRE&quot; class</summary>
      
    
    
    
    <category term="后端开发" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java基础" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://example.com/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-11-30T14:25:41.000Z</published>
    <updated>2024-11-30T14:37:32.290Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是我的第一篇博客！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="生活随笔" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
