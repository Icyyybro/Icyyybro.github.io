<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Icyyybro</title>
  
  <subtitle>欢迎来到Yichuan Wang的世界</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-03T11:38:20.472Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>YiChuan Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基本数据类型</title>
    <link href="http://example.com/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-12-03T11:35:55.000Z</published>
    <updated>2024-12-03T11:38:20.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h1 id="1-包装类型"><a href="#1-包装类型" class="headerlink" title="1. 包装类型"></a>1. 包装类型</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>Java 的包装类型（Wrapper Class）是对基本数据类型的对象表示，用于将基本数据类型（如 <code>int</code>、<code>double</code>）包装为类对象。包装类存在的主要目的是使基本数据类型能够与 Java 的集合框架（如 <code>ArrayList</code>）等只能操作对象的API兼容。</p><h2 id="1-2-基本类型和包装类型的区别"><a href="#1-2-基本类型和包装类型的区别" class="headerlink" title="1.2 基本类型和包装类型的区别"></a>1.2 基本类型和包装类型的区别</h2><ul><li>用途：定义一些常用变量或局部变量会使用基本类型；在对象属性，方法参数中会使用包装类型，同时包装类型可用于泛型。</li><li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，存储在堆中。</li><li>占用空间：基本数据类型占用空间小。</li><li>默认值：成员变量包装类不赋值就是null，基本数据类型有默认值。</li><li>比较方式：基本数据类型中，&#x3D;&#x3D;比较的是数值是否相同；对于包装类型来说，&#x3D;&#x3D;比较的是对象的内存地址，equals可以比较数值大小。</li></ul><h2 id="1-3-包装类型的缓存机制"><a href="#1-3-包装类型的缓存机制" class="headerlink" title="1.3 包装类型的缓存机制"></a>1.3 包装类型的缓存机制</h2><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><h2 id="1-4-自动装箱与拆箱"><a href="#1-4-自动装箱与拆箱" class="headerlink" title="1.4 自动装箱与拆箱"></a>1.4 自动装箱与拆箱</h2><h3 id="1-4-1-定义"><a href="#1-4-1-定义" class="headerlink" title="1.4.1 定义"></a>1.4.1 定义</h3><p>自动装箱：将基本数据类型转换为对应的包装类对象。</p><p>自动拆箱：将包装类对象自动转换为对应的基本数据类型。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2-综合理解装箱和包装类缓存机制"><a href="#1-4-2-综合理解装箱和包装类缓存机制" class="headerlink" title="1.4.2 综合理解装箱和包装类缓存机制"></a>1.4.2 综合理解装箱和包装类缓存机制</h3><p>下面我们来看一个问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);</span><br></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。</p><p>下面是另一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">// true, 因为值在缓存范围内（-128 到 127）</span></span><br><span class="line">System.out.println(a.equals(b));  <span class="comment">// true, 比较值</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(c == d);  <span class="comment">// false, 超出缓存范围</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-BigDecimal"><a href="#2-BigDecimal" class="headerlink" title="2. BigDecimal"></a>2. BigDecimal</h1><h2 id="2-1-为什么浮点数运算的时候会有精度丢失的风险"><a href="#2-1-为什么浮点数运算的时候会有精度丢失的风险" class="headerlink" title="2.1 为什么浮点数运算的时候会有精度丢失的风险"></a>2.1 为什么浮点数运算的时候会有精度丢失的风险</h2><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h2 id="2-2-如何解决这个问题"><a href="#2-2-如何解决这个问题" class="headerlink" title="2.2 如何解决这个问题"></a>2.2 如何解决这个问题</h2><p>使用BigDecimal，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(c);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.2 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.20 */</span></span><br><span class="line"><span class="comment">// 比较内容，不是比较值</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* false */</span></span><br><span class="line"><span class="comment">// 比较值相等用相等compareTo，相等返回0</span></span><br><span class="line">System.out.println(<span class="number">0</span> == x.compareTo(y)); <span class="comment">/* true */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BigDecimal 是以字符串或整数形式存储的，所有运算都遵循十进制规则。</p><h1 id="3-超过long整型数据应该如何表示"><a href="#3-超过long整型数据应该如何表示" class="headerlink" title="3. 超过long整型数据应该如何表示"></a>3. 超过long整型数据应该如何表示</h1><p>使用BigInteger，<code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h1&gt;&lt;h1 id=&quot;1-包装类型&quot;&gt;&lt;a href=&quot;#1-包装类型&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="后端开发" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java基础" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java自定义注解</title>
    <link href="http://example.com/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <id>http://example.com/2024/12/03/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/java%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</id>
    <published>2024-12-03T11:26:20.000Z</published>
    <updated>2024-12-03T11:38:06.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公共字段填充"><a href="#公共字段填充" class="headerlink" title="公共字段填充"></a>公共字段填充</h1><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p>我们在update和insert操作时需要修改创建时间，修改时间，修改人id，且这几种属性都属于公共属性，即所有的表都含有这个属性，如果通过service操作会显得非常繁琐，所以我们使用自定义注解的方式完成。</p><h1 id="2-自定义注解AtuoFill"><a href="#2-自定义注解AtuoFill" class="headerlink" title="2. 自定义注解AtuoFill"></a>2. 自定义注解AtuoFill</h1><p>自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法。自定义注解前要写上两个注解：</p><ul><li>一个是@Target(ElementType.METHOD)，这个注解用来指定当前注解只能加在方法上。</li><li>另一个注解是@Retention(RetentionPolicy.RUNTIME)，这个注解用来指定当前注解在什么阶段被保留，这里表示注解在运行时会被 JVM 保留</li></ul><p>这里的value是注解的一个属性，它的作用是接收一个 OperationType 类型的值，该值用来表示操作的类型（例如 INSERT 或 UPDATE）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span>     <span class="comment">//指定当前注解只能加在方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>     <span class="comment">//指定当前注解的生命周期，这里表示注解在运行时会被 JVM 保留</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    <span class="comment">//指定数据库操作类型: UPDATE, INSERT</span></span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-定义切面类"><a href="#3-定义切面类" class="headerlink" title="3. 定义切面类"></a>3. 定义切面类</h1><p>因为要想实现自动填充方法，我们就需要在程序insert&#x2F;update前拦截这个mapper方法，并进行相关操作，这时就用到了切面编程的相关思想。</p><h2 id="3-1-切面类"><a href="#3-1-切面类" class="headerlink" title="3.1 切面类"></a>3.1 切面类</h2><p>声明一个类为切面类，切面类可以包含：</p><ul><li><strong>通知（Advice）</strong>：在程序执行的特定点（切点）上执行的代码。</li><li><strong>切点（Pointcut）</strong>：定义在哪些连接点上执行通知。</li><li><strong>引入（Introduction）</strong>：向目标类添加新的方法或属性。</li></ul><p>简单来说，切点的目的是告诉这个切面类哪些方法可以拦截；通知是拦截前&#x2F;后需要执行的操作，所以又可以分为前置通知，后置通知，返回通知，。</p><ul><li><strong>前置通知@Before</strong>：在目标方法执行之前执行的通知。用于在方法执行前进行准备工作，如参数校验、权限检查等。</li><li><strong>后置通知@After</strong>：在目标方法执行之后执行的通知，不管目标方法是否抛出异常。用于执行清理操作，如释放资源等。</li><li><strong>返回通知@AfterReturning</strong>：在目标方法正常执行完毕后执行的通知，且能够访问目标方法的返回值。用于在方法执行完后对返回结果进行处理，如日志记录、返回值的修改等。</li><li><strong>异常通知@AfterThrowing</strong>：当目标方法抛出异常时执行的通知。用于处理异常，比如日志记录、异常处理等。</li><li><strong>环绕通知（@Around）</strong>：包围目标方法执行的通知，可以控制目标方法的执行，甚至可以选择不执行目标方法。用于在方法执行前后加入自定义逻辑，例如：事务管理、性能统计等。它是最强大的通知类型，可以访问方法的参数、返回值，还可以控制目标方法是否执行。</li></ul><h2 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h2><h3 id="3-2-1-获取数据库操作类型"><a href="#3-2-1-获取数据库操作类型" class="headerlink" title="3.2.1 获取数据库操作类型"></a>3.2.1 获取数据库操作类型</h3><p>首先需要获得当前被拦截方法的数据库操作类型insert&#x2F;update，这里使用了反射的知识，joinPoint参数是被拦截的方法的信息，通过使用joinPoint，我们可以获得被拦截的方法的具体参数等信息。</p><p>我们使用joinPoint.getSignature()获得方法签名对象，但是signature是父类，其中没有获得方法参数的具体实现，所以我们要将他转化为子类MethodSignature，子类重写了父类方法，可以获得被拦截的方法信息。</p><p>再通过getAnnotation可以获得注解对象，同时调用注解对象的value属性就可以获得操作类型是insert还是update了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// joinPoint为拦截时传入的参数</span></span><br><span class="line">        log.info(<span class="string">&quot;开始进行公共字段的自动填充...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前被拦截方法的数据库操作类型</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();     <span class="comment">//方法签名对象</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);        <span class="comment">//获得方法上的注解对象</span></span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value();     <span class="comment">//获得数据库操作类型</span></span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-获取当前被拦截的方法参数（实体对象）"><a href="#3-2-2-获取当前被拦截的方法参数（实体对象）" class="headerlink" title="3.2.2 获取当前被拦截的方法参数（实体对象）"></a>3.2.2 获取当前被拦截的方法参数（实体对象）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前被拦截的方法参数（实体对象）</span></span><br><span class="line">Object[] args = joinPoint.getArgs();</span><br><span class="line"><span class="keyword">if</span>(args == <span class="literal">null</span> || args.length == <span class="number">0</span>) &#123;      <span class="comment">//如果没有参数，返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>];    <span class="comment">//得到第一个参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-3-准备数据"><a href="#3-2-3-准备数据" class="headerlink" title="3.2.3 准备数据"></a>3.2.3 准备数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备赋值的数据</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">Long</span> <span class="variable">currentId</span> <span class="operator">=</span> BaseContext.getCurrentId();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-4-赋值"><a href="#3-2-4-赋值" class="headerlink" title="3.2.4 赋值"></a>3.2.4 赋值</h3><p>先使用entity反射获得方法，再通过invoke去使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据当前不同操作类型，为对应的属性通过反射来赋值</span></span><br><span class="line">        <span class="keyword">if</span>(operationType == OperationType.INSERT) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setCreateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setCreateUser&quot;</span>, Long.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, Long.class);</span><br><span class="line"></span><br><span class="line">                setCreateTime.invoke(entity, localDateTime);</span><br><span class="line">                setUpdateTime.invoke(entity, localDateTime);</span><br><span class="line">                setCreateUser.invoke(entity, currentId);</span><br><span class="line">                setUpdateUser.invoke(entity, currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operationType == OperationType.UPDATE) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Method setCreateTime = entity.getClass().getDeclaredMethod(&quot;setCreateTime&quot;, LocalDateTime.class);</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="comment">//Method setCreateUser = entity.getClass().getDeclaredMethod(&quot;setCreateUser&quot;, Long.class);</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateUser</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateUser&quot;</span>, Long.class);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//setCreateTime.invoke(entity, localDateTime);</span></span><br><span class="line">                setUpdateTime.invoke(entity, localDateTime);</span><br><span class="line">                <span class="comment">//setCreateUser.invoke(entity, currentId);</span></span><br><span class="line">                setUpdateUser.invoke(entity, currentId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公共字段填充&quot;&gt;&lt;a href=&quot;#公共字段填充&quot; class=&quot;headerlink&quot; title=&quot;公共字段填充&quot;&gt;&lt;/a&gt;公共字段填充&lt;/h1&gt;&lt;h1 id=&quot;1-问题&quot;&gt;&lt;a href=&quot;#1-问题&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="后端开发" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="苍穹项目笔记" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/%E8%8B%8D%E7%A9%B9%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础概念与常识</title>
    <link href="http://example.com/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/"/>
    <id>http://example.com/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/</id>
    <published>2024-12-02T11:17:32.000Z</published>
    <updated>2024-12-03T11:33:03.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h1><h1 id="1-JVM与JDK与JRE"><a href="#1-JVM与JDK与JRE" class="headerlink" title="1. JVM与JDK与JRE"></a>1. JVM与JDK与JRE</h1><h2 id="1-1-JVM"><a href="#1-1-JVM" class="headerlink" title="1.1 JVM"></a>1.1 JVM</h2><p>JVM是java虚拟机，是运行java字节码的虚拟机。JVM会针对不同的操作系统开发不同版本的JVM，目的是在不同操作系统上运行相同的字节码都会给出相同的结果。</p><p>同时，不同的编程语言都可以生成字节码，并运行在jvm上</p><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_I2PrrZf6yR.png"></p><h2 id="1-2-JDK"><a href="#1-2-JDK" class="headerlink" title="1.2 JDK"></a>1.2 JDK</h2><p>jdk全称为Java Development Kit，是java开发工具包。它包含了：JRE（java runtime environment），编译器javac和其他工具。</p><h2 id="1-3-JRE"><a href="#1-3-JRE" class="headerlink" title="1.3 JRE"></a>1.3 JRE</h2><p>jre是java运行已编译java程序的环境，主要包括：JVM，java基础类库。</p><h2 id="1-4-JDK和JRE的关系"><a href="#1-4-JDK和JRE的关系" class="headerlink" title="1.4 JDK和JRE的关系"></a>1.4 JDK和JRE的关系</h2><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_nYdCCkPCQa.png"></p><h1 id="2-字节码"><a href="#2-字节码" class="headerlink" title="2. 字节码"></a>2. 字节码</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h2><p>字节码就是java程序编译后生成的.class文件。字节码只面向JVM虚拟机。</p><h2 id="2-2-好处"><a href="#2-2-好处" class="headerlink" title="2.2 好处"></a>2.2 好处</h2><p>字节码只面向JVM虚拟机，不面向任何特定处理器。这样会在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><h2 id="2-3-java程序运行过程-x20"><a href="#2-3-java程序运行过程-x20" class="headerlink" title="2.3 java程序运行过程&#x20;"></a>2.3 java程序运行过程&#x20;</h2><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_l-yZMFDxNr.png"></p><h2 id="2-4-解释器与JIT"><a href="#2-4-解释器与JIT" class="headerlink" title="2.4 解释器与JIT"></a>2.4 解释器与JIT</h2><p>在.class文件到机器码这一步中，JVM首先加载字节码的文件，然后通过解释器逐行解释代码，这种逐行解释的方式较慢，所以引入了JIT（just in time）编译器，JIT属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。</p><p>这里补充一下解释器和编译器的区别：</p><ul><li>编译器将字节码<strong>一次性翻译成完整的机器码</strong>。</li><li>解释器逐条将字节码翻译为机器码，再执行。</li></ul><p>从.class → 机器码这一过程可以看出，java既使用了编译器，又使用了解释器，所以java是编译与解释共存的语言。</p><p><img src="/2024/12/02/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86/image_1SrpaNkuzr.png"></p><h1 id="3-AOT"><a href="#3-AOT" class="headerlink" title="3. AOT"></a>3. AOT</h1><h2 id="3-1-AOT是什么"><a href="#3-1-AOT是什么" class="headerlink" title="3.1 AOT是什么"></a>3.1 AOT是什么</h2><p>AOT全称为ahead of time compilation，意思是在程序被执行前就将其编译成机器码，属于静态编译（类似于C++）</p><h2 id="3-2-AOT优点"><a href="#3-2-AOT优点" class="headerlink" title="3.2 AOT优点"></a>3.2 AOT优点</h2><p>AOT 的主要优势在于启动时间、内存占用和打包体积。</p><ul><li>AOT避免了JIT预热的开销，提高了java的启动速度。</li><li>减少内存占用：JIT和解释器都需要用字节码，而AOT模式在程序部署前就已经编译为本地机器码，不需要解释器和JIT编译器。</li><li>增强程序安全性：很难反编译。</li></ul><h2 id="3-3-AOT与JIT"><a href="#3-3-AOT与JIT" class="headerlink" title="3.3 AOT与JIT"></a>3.3 AOT与JIT</h2><p>AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理。而很多框架都要用到这些动态特性，如spring。</p><p>JIT具备更高的极限处理能力（JIT可以记录很多热点代码）</p><h1 id="4-java和C-区别"><a href="#4-java和C-区别" class="headerlink" title="4. java和C++区别"></a>4. java和C++区别</h1><ul><li>java中不提供指针访问内存，线程更加安全</li><li>java的类是单继承，C++的类可以多继承。但是java的接口可以多继承</li><li>java可以自动回收内存</li><li>C++支持方法重载和运算符重载，java只支持方法重载。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念与常识&quot;&gt;&lt;a href=&quot;#基础概念与常识&quot; class=&quot;headerlink&quot; title=&quot;基础概念与常识&quot;&gt;&lt;/a&gt;基础概念与常识&lt;/h1&gt;&lt;h1 id=&quot;1-JVM与JDK与JRE&quot;&gt;&lt;a href=&quot;#1-JVM与JDK与JRE&quot; class</summary>
      
    
    
    
    <category term="后端开发" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="java基础" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://example.com/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2024/11/30/%E5%85%B6%E4%BB%96/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2024-11-30T14:25:41.000Z</published>
    <updated>2024-11-30T14:37:32.290Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是我的第一篇博客！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="生活随笔" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
